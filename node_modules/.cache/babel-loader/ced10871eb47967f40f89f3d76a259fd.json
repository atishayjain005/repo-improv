{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @emails oncall+relay\n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar LRUCache = require('./LRUCache');\n\nvar invariant = require('invariant');\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar _require = require('relay-runtime'),\n    isPromise = _require.isPromise;\n\nvar CACHE_CAPACITY = 1000;\nvar DEFAULT_FETCH_POLICY = 'store-or-network';\nvar DATA_RETENTION_TIMEOUT = 5 * 60 * 1000;\nvar WEAKMAP_SUPPORTED = typeof WeakMap === 'function';\n\nfunction operationIsLiveQuery(operation) {\n  return operation.request.node.params.metadata.live !== undefined;\n}\n\nfunction getQueryCacheIdentifier(environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker) {\n  var fetchPolicy = maybeFetchPolicy !== null && maybeFetchPolicy !== void 0 ? maybeFetchPolicy : DEFAULT_FETCH_POLICY;\n  var renderPolicy = maybeRenderPolicy !== null && maybeRenderPolicy !== void 0 ? maybeRenderPolicy : environment.UNSTABLE_getDefaultRenderPolicy();\n  var cacheIdentifier = \"\".concat(fetchPolicy, \"-\").concat(renderPolicy, \"-\").concat(operation.request.identifier);\n\n  if (cacheBreaker != null) {\n    return \"\".concat(cacheIdentifier, \"-\").concat(cacheBreaker);\n  }\n\n  return cacheIdentifier;\n}\n\nfunction getQueryResult(operation, cacheIdentifier) {\n  var rootFragmentRef = {\n    __id: operation.fragment.dataID,\n    __fragments: (0, _defineProperty2[\"default\"])({}, operation.fragment.node.name, operation.request.variables),\n    __fragmentOwner: operation.request\n  };\n  return {\n    cacheIdentifier: cacheIdentifier,\n    fragmentNode: operation.request.node.fragment,\n    fragmentRef: rootFragmentRef,\n    operation: operation\n  };\n}\n\nvar nextID = 200000;\n\nfunction createCacheEntry(cacheIdentifier, operation, operationAvailability, value, networkSubscription, onDispose) {\n  var isLiveQuery = operationIsLiveQuery(operation);\n  var currentValue = value;\n  var retainCount = 0;\n  var retainDisposable = null;\n  var _releaseTemporaryRetain = null;\n  var currentNetworkSubscription = networkSubscription;\n\n  var retain = function retain(environment) {\n    retainCount++;\n\n    if (retainCount === 1) {\n      retainDisposable = environment.retain(operation);\n    }\n\n    return {\n      dispose: function dispose() {\n        retainCount = Math.max(0, retainCount - 1);\n\n        if (retainCount === 0) {\n          !(retainDisposable != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected disposable to release query to be defined.' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0;\n          retainDisposable.dispose();\n          retainDisposable = null;\n        }\n\n        onDispose(cacheEntry);\n      }\n    };\n  };\n\n  var cacheEntry = {\n    cacheIdentifier: cacheIdentifier,\n    id: nextID++,\n    processedPayloadsCount: 0,\n    operationAvailability: operationAvailability,\n    getValue: function getValue() {\n      return currentValue;\n    },\n    setValue: function setValue(val) {\n      currentValue = val;\n    },\n    getRetainCount: function getRetainCount() {\n      return retainCount;\n    },\n    getNetworkSubscription: function getNetworkSubscription() {\n      return currentNetworkSubscription;\n    },\n    setNetworkSubscription: function setNetworkSubscription(subscription) {\n      if (isLiveQuery && currentNetworkSubscription != null) {\n        currentNetworkSubscription.unsubscribe();\n      }\n\n      currentNetworkSubscription = subscription;\n    },\n    temporaryRetain: function temporaryRetain(environment) {\n      // NOTE: If we're executing in a server environment, there's no need\n      // to create temporary retains, since the component will never commit.\n      if (environment.isServer()) {\n        return {\n          dispose: function dispose() {}\n        };\n      } // NOTE: temporaryRetain is called during the render phase. However,\n      // given that we can't tell if this render will eventually commit or not,\n      // we create a timer to autodispose of this retain in case the associated\n      // component never commits.\n      // If the component /does/ commit, permanentRetain will clear this timeout\n      // and permanently retain the data.\n\n\n      var disposable = retain(environment);\n      var releaseQueryTimeout = null;\n\n      var localReleaseTemporaryRetain = function localReleaseTemporaryRetain() {\n        clearTimeout(releaseQueryTimeout);\n        releaseQueryTimeout = null;\n        _releaseTemporaryRetain = null;\n        disposable.dispose(); // Normally if this entry never commits, the request would've ended by the\n        // time this timeout expires and the temporary retain is released. However,\n        // we need to do this for live queries which remain open indefinitely.\n\n        if (isLiveQuery && retainCount <= 0 && currentNetworkSubscription != null) {\n          currentNetworkSubscription.unsubscribe();\n        }\n      };\n\n      releaseQueryTimeout = setTimeout(localReleaseTemporaryRetain, DATA_RETENTION_TIMEOUT); // NOTE: Since temporaryRetain can be called multiple times, we release\n      // the previous temporary retain after we re-establish a new one, since\n      // we only ever need a single temporary retain until the permanent retain is\n      // established.\n      // temporaryRetain may be called multiple times by React during the render\n      // phase, as well as multiple times by other query components that are\n      // rendering the same query/variables.\n\n      if (_releaseTemporaryRetain != null) {\n        _releaseTemporaryRetain();\n      }\n\n      _releaseTemporaryRetain = localReleaseTemporaryRetain;\n      return {\n        dispose: function dispose() {\n          _releaseTemporaryRetain && _releaseTemporaryRetain();\n        }\n      };\n    },\n    permanentRetain: function permanentRetain(environment) {\n      var disposable = retain(environment);\n\n      if (_releaseTemporaryRetain != null) {\n        _releaseTemporaryRetain();\n\n        _releaseTemporaryRetain = null;\n      }\n\n      return {\n        dispose: function dispose() {\n          disposable.dispose();\n\n          if (isLiveQuery && retainCount <= 0 && currentNetworkSubscription != null) {\n            currentNetworkSubscription.unsubscribe();\n          }\n        }\n      };\n    },\n    releaseTemporaryRetain: function releaseTemporaryRetain() {\n      if (_releaseTemporaryRetain != null) {\n        _releaseTemporaryRetain();\n\n        _releaseTemporaryRetain = null;\n      }\n    }\n  };\n  return cacheEntry;\n}\n\nvar QueryResourceImpl = /*#__PURE__*/function () {\n  function QueryResourceImpl(environment) {\n    var _this = this;\n\n    (0, _defineProperty2[\"default\"])(this, \"_clearCacheEntry\", function (cacheEntry) {\n      if (cacheEntry.getRetainCount() <= 0) {\n        _this._cache[\"delete\"](cacheEntry.cacheIdentifier);\n      }\n    });\n    this._environment = environment;\n    this._cache = LRUCache.create(CACHE_CAPACITY);\n  }\n\n  var _proto = QueryResourceImpl.prototype;\n\n  _proto.prepare = function prepare(operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, cacheBreaker, profilerContext) {\n    var cacheIdentifier = getQueryCacheIdentifier(this._environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker);\n    return this.prepareWithIdentifier(cacheIdentifier, operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, profilerContext);\n  }\n  /**\n   * This function should be called during a Component's render function,\n   * to either read an existing cached value for the query, or fetch the query\n   * and suspend.\n   */\n  ;\n\n  _proto.prepareWithIdentifier = function prepareWithIdentifier(cacheIdentifier, operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, profilerContext) {\n    var environment = this._environment;\n    var fetchPolicy = maybeFetchPolicy !== null && maybeFetchPolicy !== void 0 ? maybeFetchPolicy : DEFAULT_FETCH_POLICY;\n    var renderPolicy = maybeRenderPolicy !== null && maybeRenderPolicy !== void 0 ? maybeRenderPolicy : environment.UNSTABLE_getDefaultRenderPolicy(); // 1. Check if there's a cached value for this operation, and reuse it if\n    // it's available\n\n    var cacheEntry = this._cache.get(cacheIdentifier);\n\n    var temporaryRetainDisposable = null;\n    var entryWasCached = cacheEntry != null;\n\n    if (cacheEntry == null) {\n      // 2. If a cached value isn't available, try fetching the operation.\n      // _fetchAndSaveQuery will update the cache with either a Promise or\n      // an Error to throw, or a QueryResult to return.\n      cacheEntry = this._fetchAndSaveQuery(cacheIdentifier, operation, fetchObservable, fetchPolicy, renderPolicy, profilerContext, (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, observer), {}, {\n        unsubscribe: function unsubscribe(subscription) {\n          // 4. If the request is cancelled, make sure to dispose\n          // of the temporary retain; this will ensure that a promise\n          // doesn't remain unnecessarily cached until the temporary retain\n          // expires. Not clearing the temporary retain might cause the\n          // query to incorrectly re-suspend.\n          if (temporaryRetainDisposable != null) {\n            temporaryRetainDisposable.dispose();\n          }\n\n          var observerUnsubscribe = observer === null || observer === void 0 ? void 0 : observer.unsubscribe;\n          observerUnsubscribe && observerUnsubscribe(subscription);\n        }\n      }));\n    } // 3. Temporarily retain here in render phase. When the component reading\n    // the operation is committed, we will transfer ownership of data retention\n    // to the component.\n    // In case the component never commits (mounts or updates) from this render,\n    // this data retention hold will auto-release itself after a timeout.\n\n\n    temporaryRetainDisposable = cacheEntry.temporaryRetain(environment);\n    var cachedValue = cacheEntry.getValue();\n\n    if (isPromise(cachedValue)) {\n      environment.__log({\n        name: 'suspense.query',\n        fetchPolicy: fetchPolicy,\n        isPromiseCached: entryWasCached,\n        operation: operation,\n        queryAvailability: cacheEntry.operationAvailability,\n        renderPolicy: renderPolicy\n      });\n\n      throw cachedValue;\n    }\n\n    if (cachedValue instanceof Error) {\n      throw cachedValue;\n    }\n\n    return cachedValue;\n  }\n  /**\n   * This function should be called during a component's commit phase\n   * (e.g. inside useEffect), in order to retain the operation in the Relay store\n   * and transfer ownership of the operation to the component lifecycle.\n   */\n  ;\n\n  _proto.retain = function retain(queryResult, profilerContext) {\n    var environment = this._environment;\n    var cacheIdentifier = queryResult.cacheIdentifier,\n        operation = queryResult.operation;\n\n    var cacheEntry = this._getOrCreateCacheEntry(cacheIdentifier, operation, null, queryResult, null);\n\n    var disposable = cacheEntry.permanentRetain(environment);\n\n    environment.__log({\n      name: 'queryresource.retain',\n      profilerContext: profilerContext,\n      resourceID: cacheEntry.id\n    });\n\n    return {\n      dispose: function dispose() {\n        disposable.dispose();\n      }\n    };\n  };\n\n  _proto.releaseTemporaryRetain = function releaseTemporaryRetain(queryResult) {\n    var cacheEntry = this._cache.get(queryResult.cacheIdentifier);\n\n    if (cacheEntry != null) {\n      cacheEntry.releaseTemporaryRetain();\n    }\n  };\n\n  _proto.TESTS_ONLY__getCacheEntry = function TESTS_ONLY__getCacheEntry(operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker) {\n    var environment = this._environment;\n    var cacheIdentifier = getQueryCacheIdentifier(environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker);\n    return this._cache.get(cacheIdentifier);\n  };\n\n  _proto._getOrCreateCacheEntry = function _getOrCreateCacheEntry(cacheIdentifier, operation, operationAvailability, value, networkSubscription) {\n    var cacheEntry = this._cache.get(cacheIdentifier);\n\n    if (cacheEntry == null) {\n      cacheEntry = createCacheEntry(cacheIdentifier, operation, operationAvailability, value, networkSubscription, this._clearCacheEntry);\n\n      this._cache.set(cacheIdentifier, cacheEntry);\n    }\n\n    return cacheEntry;\n  };\n\n  _proto._fetchAndSaveQuery = function _fetchAndSaveQuery(cacheIdentifier, operation, fetchObservable, fetchPolicy, renderPolicy, profilerContext, observer) {\n    var _this2 = this;\n\n    var environment = this._environment; // NOTE: Running `check` will write missing data to the store using any\n    // missing data handlers specified on the environment;\n    // We run it here first to make the handlers get a chance to populate\n    // missing data.\n\n    var queryAvailability = environment.check(operation);\n    var queryStatus = queryAvailability.status;\n    var hasFullQuery = queryStatus === 'available';\n    var canPartialRender = hasFullQuery || renderPolicy === 'partial' && queryStatus !== 'stale';\n    var shouldFetch;\n    var shouldAllowRender;\n\n    var resolveNetworkPromise = function resolveNetworkPromise() {};\n\n    switch (fetchPolicy) {\n      case 'store-only':\n        {\n          shouldFetch = false;\n          shouldAllowRender = true;\n          break;\n        }\n\n      case 'store-or-network':\n        {\n          shouldFetch = !hasFullQuery;\n          shouldAllowRender = canPartialRender;\n          break;\n        }\n\n      case 'store-and-network':\n        {\n          shouldFetch = true;\n          shouldAllowRender = canPartialRender;\n          break;\n        }\n\n      case 'network-only':\n      default:\n        {\n          shouldFetch = true;\n          shouldAllowRender = false;\n          break;\n        }\n    } // NOTE: If this value is false, we will cache a promise for this\n    // query, which means we will suspend here at this query root.\n    // If it's true, we will cache the query resource and allow rendering to\n    // continue.\n\n\n    if (shouldAllowRender) {\n      var queryResult = getQueryResult(operation, cacheIdentifier);\n\n      var _cacheEntry = createCacheEntry(cacheIdentifier, operation, queryAvailability, queryResult, null, this._clearCacheEntry);\n\n      this._cache.set(cacheIdentifier, _cacheEntry);\n    }\n\n    if (shouldFetch) {\n      var _queryResult = getQueryResult(operation, cacheIdentifier);\n\n      var networkSubscription;\n      fetchObservable.subscribe({\n        start: function start(subscription) {\n          networkSubscription = subscription;\n\n          var cacheEntry = _this2._cache.get(cacheIdentifier);\n\n          if (cacheEntry) {\n            cacheEntry.setNetworkSubscription(networkSubscription);\n          }\n\n          var observerStart = observer === null || observer === void 0 ? void 0 : observer.start;\n\n          if (observerStart) {\n            var subscriptionWithConditionalCancelation = (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, subscription), {}, {\n              unsubscribe: function unsubscribe() {\n                // Only live queries should have their network requests canceled.\n                if (operationIsLiveQuery(operation)) {\n                  subscription.unsubscribe();\n                }\n              }\n            });\n            observerStart(subscriptionWithConditionalCancelation);\n          }\n        },\n        next: function next() {\n          var cacheEntry = _this2._getOrCreateCacheEntry(cacheIdentifier, operation, queryAvailability, _queryResult, networkSubscription);\n\n          cacheEntry.processedPayloadsCount += 1;\n          cacheEntry.setValue(_queryResult);\n          resolveNetworkPromise();\n          var observerNext = observer === null || observer === void 0 ? void 0 : observer.next;\n\n          if (observerNext != null) {\n            var snapshot = environment.lookup(operation.fragment);\n            observerNext(snapshot);\n          }\n        },\n        error: function error(_error) {\n          var cacheEntry = _this2._getOrCreateCacheEntry(cacheIdentifier, operation, queryAvailability, _error, networkSubscription); // If, this is the first thing we receive for the query,\n          // before any other payload handled is error, we will cache and\n          // re-throw that error later.\n          // We will ignore errors for any incremental payloads we receive.\n\n\n          if (cacheEntry.processedPayloadsCount === 0) {\n            cacheEntry.setValue(_error);\n          } else {\n            // TODO:T92030819 Remove this warning and actually throw the network error\n            // To complete this task we need to have a way of precisely tracking suspendable points\n            process.env.NODE_ENV !== \"production\" ? warning(false, 'QueryResource: An incremental payload for query `%` returned an error: `%`:`%`.', operation.fragment.node.name, _error.message, _error.stack) : void 0;\n          }\n\n          resolveNetworkPromise();\n          networkSubscription = null;\n          cacheEntry.setNetworkSubscription(null);\n          var observerError = observer === null || observer === void 0 ? void 0 : observer.error;\n          observerError && observerError(_error);\n        },\n        complete: function complete() {\n          resolveNetworkPromise();\n          networkSubscription = null;\n\n          var cacheEntry = _this2._cache.get(cacheIdentifier);\n\n          if (cacheEntry) {\n            cacheEntry.setNetworkSubscription(null);\n          }\n\n          var observerComplete = observer === null || observer === void 0 ? void 0 : observer.complete;\n          observerComplete && observerComplete();\n        },\n        unsubscribe: observer === null || observer === void 0 ? void 0 : observer.unsubscribe\n      });\n\n      var _cacheEntry2 = this._cache.get(cacheIdentifier);\n\n      if (!_cacheEntry2) {\n        var networkPromise = new Promise(function (resolve) {\n          resolveNetworkPromise = resolve;\n        }); // $FlowExpectedError[prop-missing] Expando to annotate Promises.\n\n        networkPromise.displayName = 'Relay(' + operation.fragment.node.name + ')';\n        _cacheEntry2 = createCacheEntry(cacheIdentifier, operation, queryAvailability, networkPromise, networkSubscription, this._clearCacheEntry);\n\n        this._cache.set(cacheIdentifier, _cacheEntry2);\n      }\n    } else {\n      var observerComplete = observer === null || observer === void 0 ? void 0 : observer.complete;\n      observerComplete && observerComplete();\n    }\n\n    var cacheEntry = this._cache.get(cacheIdentifier);\n\n    !(cacheEntry != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected to have cached a result when attempting to fetch query.' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0;\n\n    environment.__log({\n      name: 'queryresource.fetch',\n      resourceID: cacheEntry.id,\n      operation: operation,\n      profilerContext: profilerContext,\n      fetchPolicy: fetchPolicy,\n      renderPolicy: renderPolicy,\n      queryAvailability: queryAvailability,\n      shouldFetch: shouldFetch\n    });\n\n    return cacheEntry;\n  };\n\n  return QueryResourceImpl;\n}();\n\nfunction createQueryResource(environment) {\n  return new QueryResourceImpl(environment);\n}\n\nvar dataResources = WEAKMAP_SUPPORTED ? new WeakMap() : new Map();\n\nfunction getQueryResourceForEnvironment(environment) {\n  var cached = dataResources.get(environment);\n\n  if (cached) {\n    return cached;\n  }\n\n  var newDataResource = createQueryResource(environment);\n  dataResources.set(environment, newDataResource);\n  return newDataResource;\n}\n\nmodule.exports = {\n  createQueryResource: createQueryResource,\n  getQueryResourceForEnvironment: getQueryResourceForEnvironment,\n  getQueryCacheIdentifier: getQueryCacheIdentifier\n};","map":{"version":3,"sources":["/home/akshay/Atishay/appointy-screening/node_modules/react-relay/lib/relay-hooks/QueryResource.js"],"names":["_interopRequireDefault","require","_objectSpread2","_defineProperty2","LRUCache","invariant","warning","_require","isPromise","CACHE_CAPACITY","DEFAULT_FETCH_POLICY","DATA_RETENTION_TIMEOUT","WEAKMAP_SUPPORTED","WeakMap","operationIsLiveQuery","operation","request","node","params","metadata","live","undefined","getQueryCacheIdentifier","environment","maybeFetchPolicy","maybeRenderPolicy","cacheBreaker","fetchPolicy","renderPolicy","UNSTABLE_getDefaultRenderPolicy","cacheIdentifier","concat","identifier","getQueryResult","rootFragmentRef","__id","fragment","dataID","__fragments","name","variables","__fragmentOwner","fragmentNode","fragmentRef","nextID","createCacheEntry","operationAvailability","value","networkSubscription","onDispose","isLiveQuery","currentValue","retainCount","retainDisposable","_releaseTemporaryRetain","currentNetworkSubscription","retain","dispose","Math","max","process","env","NODE_ENV","cacheEntry","id","processedPayloadsCount","getValue","setValue","val","getRetainCount","getNetworkSubscription","setNetworkSubscription","subscription","unsubscribe","temporaryRetain","isServer","disposable","releaseQueryTimeout","localReleaseTemporaryRetain","clearTimeout","setTimeout","permanentRetain","releaseTemporaryRetain","QueryResourceImpl","_this","_cache","_environment","create","_proto","prototype","prepare","fetchObservable","observer","profilerContext","prepareWithIdentifier","get","temporaryRetainDisposable","entryWasCached","_fetchAndSaveQuery","observerUnsubscribe","cachedValue","__log","isPromiseCached","queryAvailability","Error","queryResult","_getOrCreateCacheEntry","resourceID","TESTS_ONLY__getCacheEntry","_clearCacheEntry","set","_this2","check","queryStatus","status","hasFullQuery","canPartialRender","shouldFetch","shouldAllowRender","resolveNetworkPromise","_cacheEntry","_queryResult","subscribe","start","observerStart","subscriptionWithConditionalCancelation","next","observerNext","snapshot","lookup","error","_error","message","stack","observerError","complete","observerComplete","_cacheEntry2","networkPromise","Promise","resolve","displayName","createQueryResource","dataResources","Map","getQueryResourceForEnvironment","cached","newDataResource","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @emails oncall+relay\n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar LRUCache = require('./LRUCache');\n\nvar invariant = require('invariant');\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar _require = require('relay-runtime'),\n    isPromise = _require.isPromise;\n\nvar CACHE_CAPACITY = 1000;\nvar DEFAULT_FETCH_POLICY = 'store-or-network';\nvar DATA_RETENTION_TIMEOUT = 5 * 60 * 1000;\nvar WEAKMAP_SUPPORTED = typeof WeakMap === 'function';\n\nfunction operationIsLiveQuery(operation) {\n  return operation.request.node.params.metadata.live !== undefined;\n}\n\nfunction getQueryCacheIdentifier(environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker) {\n  var fetchPolicy = maybeFetchPolicy !== null && maybeFetchPolicy !== void 0 ? maybeFetchPolicy : DEFAULT_FETCH_POLICY;\n  var renderPolicy = maybeRenderPolicy !== null && maybeRenderPolicy !== void 0 ? maybeRenderPolicy : environment.UNSTABLE_getDefaultRenderPolicy();\n  var cacheIdentifier = \"\".concat(fetchPolicy, \"-\").concat(renderPolicy, \"-\").concat(operation.request.identifier);\n\n  if (cacheBreaker != null) {\n    return \"\".concat(cacheIdentifier, \"-\").concat(cacheBreaker);\n  }\n\n  return cacheIdentifier;\n}\n\nfunction getQueryResult(operation, cacheIdentifier) {\n  var rootFragmentRef = {\n    __id: operation.fragment.dataID,\n    __fragments: (0, _defineProperty2[\"default\"])({}, operation.fragment.node.name, operation.request.variables),\n    __fragmentOwner: operation.request\n  };\n  return {\n    cacheIdentifier: cacheIdentifier,\n    fragmentNode: operation.request.node.fragment,\n    fragmentRef: rootFragmentRef,\n    operation: operation\n  };\n}\n\nvar nextID = 200000;\n\nfunction createCacheEntry(cacheIdentifier, operation, operationAvailability, value, networkSubscription, onDispose) {\n  var isLiveQuery = operationIsLiveQuery(operation);\n  var currentValue = value;\n  var retainCount = 0;\n  var retainDisposable = null;\n  var _releaseTemporaryRetain = null;\n  var currentNetworkSubscription = networkSubscription;\n\n  var retain = function retain(environment) {\n    retainCount++;\n\n    if (retainCount === 1) {\n      retainDisposable = environment.retain(operation);\n    }\n\n    return {\n      dispose: function dispose() {\n        retainCount = Math.max(0, retainCount - 1);\n\n        if (retainCount === 0) {\n          !(retainDisposable != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected disposable to release query to be defined.' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0;\n          retainDisposable.dispose();\n          retainDisposable = null;\n        }\n\n        onDispose(cacheEntry);\n      }\n    };\n  };\n\n  var cacheEntry = {\n    cacheIdentifier: cacheIdentifier,\n    id: nextID++,\n    processedPayloadsCount: 0,\n    operationAvailability: operationAvailability,\n    getValue: function getValue() {\n      return currentValue;\n    },\n    setValue: function setValue(val) {\n      currentValue = val;\n    },\n    getRetainCount: function getRetainCount() {\n      return retainCount;\n    },\n    getNetworkSubscription: function getNetworkSubscription() {\n      return currentNetworkSubscription;\n    },\n    setNetworkSubscription: function setNetworkSubscription(subscription) {\n      if (isLiveQuery && currentNetworkSubscription != null) {\n        currentNetworkSubscription.unsubscribe();\n      }\n\n      currentNetworkSubscription = subscription;\n    },\n    temporaryRetain: function temporaryRetain(environment) {\n      // NOTE: If we're executing in a server environment, there's no need\n      // to create temporary retains, since the component will never commit.\n      if (environment.isServer()) {\n        return {\n          dispose: function dispose() {}\n        };\n      } // NOTE: temporaryRetain is called during the render phase. However,\n      // given that we can't tell if this render will eventually commit or not,\n      // we create a timer to autodispose of this retain in case the associated\n      // component never commits.\n      // If the component /does/ commit, permanentRetain will clear this timeout\n      // and permanently retain the data.\n\n\n      var disposable = retain(environment);\n      var releaseQueryTimeout = null;\n\n      var localReleaseTemporaryRetain = function localReleaseTemporaryRetain() {\n        clearTimeout(releaseQueryTimeout);\n        releaseQueryTimeout = null;\n        _releaseTemporaryRetain = null;\n        disposable.dispose(); // Normally if this entry never commits, the request would've ended by the\n        // time this timeout expires and the temporary retain is released. However,\n        // we need to do this for live queries which remain open indefinitely.\n\n        if (isLiveQuery && retainCount <= 0 && currentNetworkSubscription != null) {\n          currentNetworkSubscription.unsubscribe();\n        }\n      };\n\n      releaseQueryTimeout = setTimeout(localReleaseTemporaryRetain, DATA_RETENTION_TIMEOUT); // NOTE: Since temporaryRetain can be called multiple times, we release\n      // the previous temporary retain after we re-establish a new one, since\n      // we only ever need a single temporary retain until the permanent retain is\n      // established.\n      // temporaryRetain may be called multiple times by React during the render\n      // phase, as well as multiple times by other query components that are\n      // rendering the same query/variables.\n\n      if (_releaseTemporaryRetain != null) {\n        _releaseTemporaryRetain();\n      }\n\n      _releaseTemporaryRetain = localReleaseTemporaryRetain;\n      return {\n        dispose: function dispose() {\n          _releaseTemporaryRetain && _releaseTemporaryRetain();\n        }\n      };\n    },\n    permanentRetain: function permanentRetain(environment) {\n      var disposable = retain(environment);\n\n      if (_releaseTemporaryRetain != null) {\n        _releaseTemporaryRetain();\n\n        _releaseTemporaryRetain = null;\n      }\n\n      return {\n        dispose: function dispose() {\n          disposable.dispose();\n\n          if (isLiveQuery && retainCount <= 0 && currentNetworkSubscription != null) {\n            currentNetworkSubscription.unsubscribe();\n          }\n        }\n      };\n    },\n    releaseTemporaryRetain: function releaseTemporaryRetain() {\n      if (_releaseTemporaryRetain != null) {\n        _releaseTemporaryRetain();\n\n        _releaseTemporaryRetain = null;\n      }\n    }\n  };\n  return cacheEntry;\n}\n\nvar QueryResourceImpl = /*#__PURE__*/function () {\n  function QueryResourceImpl(environment) {\n    var _this = this;\n\n    (0, _defineProperty2[\"default\"])(this, \"_clearCacheEntry\", function (cacheEntry) {\n      if (cacheEntry.getRetainCount() <= 0) {\n        _this._cache[\"delete\"](cacheEntry.cacheIdentifier);\n      }\n    });\n    this._environment = environment;\n    this._cache = LRUCache.create(CACHE_CAPACITY);\n  }\n\n  var _proto = QueryResourceImpl.prototype;\n\n  _proto.prepare = function prepare(operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, cacheBreaker, profilerContext) {\n    var cacheIdentifier = getQueryCacheIdentifier(this._environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker);\n    return this.prepareWithIdentifier(cacheIdentifier, operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, profilerContext);\n  }\n  /**\n   * This function should be called during a Component's render function,\n   * to either read an existing cached value for the query, or fetch the query\n   * and suspend.\n   */\n  ;\n\n  _proto.prepareWithIdentifier = function prepareWithIdentifier(cacheIdentifier, operation, fetchObservable, maybeFetchPolicy, maybeRenderPolicy, observer, profilerContext) {\n    var environment = this._environment;\n    var fetchPolicy = maybeFetchPolicy !== null && maybeFetchPolicy !== void 0 ? maybeFetchPolicy : DEFAULT_FETCH_POLICY;\n    var renderPolicy = maybeRenderPolicy !== null && maybeRenderPolicy !== void 0 ? maybeRenderPolicy : environment.UNSTABLE_getDefaultRenderPolicy(); // 1. Check if there's a cached value for this operation, and reuse it if\n    // it's available\n\n    var cacheEntry = this._cache.get(cacheIdentifier);\n\n    var temporaryRetainDisposable = null;\n    var entryWasCached = cacheEntry != null;\n\n    if (cacheEntry == null) {\n      // 2. If a cached value isn't available, try fetching the operation.\n      // _fetchAndSaveQuery will update the cache with either a Promise or\n      // an Error to throw, or a QueryResult to return.\n      cacheEntry = this._fetchAndSaveQuery(cacheIdentifier, operation, fetchObservable, fetchPolicy, renderPolicy, profilerContext, (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, observer), {}, {\n        unsubscribe: function unsubscribe(subscription) {\n          // 4. If the request is cancelled, make sure to dispose\n          // of the temporary retain; this will ensure that a promise\n          // doesn't remain unnecessarily cached until the temporary retain\n          // expires. Not clearing the temporary retain might cause the\n          // query to incorrectly re-suspend.\n          if (temporaryRetainDisposable != null) {\n            temporaryRetainDisposable.dispose();\n          }\n\n          var observerUnsubscribe = observer === null || observer === void 0 ? void 0 : observer.unsubscribe;\n          observerUnsubscribe && observerUnsubscribe(subscription);\n        }\n      }));\n    } // 3. Temporarily retain here in render phase. When the component reading\n    // the operation is committed, we will transfer ownership of data retention\n    // to the component.\n    // In case the component never commits (mounts or updates) from this render,\n    // this data retention hold will auto-release itself after a timeout.\n\n\n    temporaryRetainDisposable = cacheEntry.temporaryRetain(environment);\n    var cachedValue = cacheEntry.getValue();\n\n    if (isPromise(cachedValue)) {\n      environment.__log({\n        name: 'suspense.query',\n        fetchPolicy: fetchPolicy,\n        isPromiseCached: entryWasCached,\n        operation: operation,\n        queryAvailability: cacheEntry.operationAvailability,\n        renderPolicy: renderPolicy\n      });\n\n      throw cachedValue;\n    }\n\n    if (cachedValue instanceof Error) {\n      throw cachedValue;\n    }\n\n    return cachedValue;\n  }\n  /**\n   * This function should be called during a component's commit phase\n   * (e.g. inside useEffect), in order to retain the operation in the Relay store\n   * and transfer ownership of the operation to the component lifecycle.\n   */\n  ;\n\n  _proto.retain = function retain(queryResult, profilerContext) {\n    var environment = this._environment;\n    var cacheIdentifier = queryResult.cacheIdentifier,\n        operation = queryResult.operation;\n\n    var cacheEntry = this._getOrCreateCacheEntry(cacheIdentifier, operation, null, queryResult, null);\n\n    var disposable = cacheEntry.permanentRetain(environment);\n\n    environment.__log({\n      name: 'queryresource.retain',\n      profilerContext: profilerContext,\n      resourceID: cacheEntry.id\n    });\n\n    return {\n      dispose: function dispose() {\n        disposable.dispose();\n      }\n    };\n  };\n\n  _proto.releaseTemporaryRetain = function releaseTemporaryRetain(queryResult) {\n    var cacheEntry = this._cache.get(queryResult.cacheIdentifier);\n\n    if (cacheEntry != null) {\n      cacheEntry.releaseTemporaryRetain();\n    }\n  };\n\n  _proto.TESTS_ONLY__getCacheEntry = function TESTS_ONLY__getCacheEntry(operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker) {\n    var environment = this._environment;\n    var cacheIdentifier = getQueryCacheIdentifier(environment, operation, maybeFetchPolicy, maybeRenderPolicy, cacheBreaker);\n    return this._cache.get(cacheIdentifier);\n  };\n\n  _proto._getOrCreateCacheEntry = function _getOrCreateCacheEntry(cacheIdentifier, operation, operationAvailability, value, networkSubscription) {\n    var cacheEntry = this._cache.get(cacheIdentifier);\n\n    if (cacheEntry == null) {\n      cacheEntry = createCacheEntry(cacheIdentifier, operation, operationAvailability, value, networkSubscription, this._clearCacheEntry);\n\n      this._cache.set(cacheIdentifier, cacheEntry);\n    }\n\n    return cacheEntry;\n  };\n\n  _proto._fetchAndSaveQuery = function _fetchAndSaveQuery(cacheIdentifier, operation, fetchObservable, fetchPolicy, renderPolicy, profilerContext, observer) {\n    var _this2 = this;\n\n    var environment = this._environment; // NOTE: Running `check` will write missing data to the store using any\n    // missing data handlers specified on the environment;\n    // We run it here first to make the handlers get a chance to populate\n    // missing data.\n\n    var queryAvailability = environment.check(operation);\n    var queryStatus = queryAvailability.status;\n    var hasFullQuery = queryStatus === 'available';\n    var canPartialRender = hasFullQuery || renderPolicy === 'partial' && queryStatus !== 'stale';\n    var shouldFetch;\n    var shouldAllowRender;\n\n    var resolveNetworkPromise = function resolveNetworkPromise() {};\n\n    switch (fetchPolicy) {\n      case 'store-only':\n        {\n          shouldFetch = false;\n          shouldAllowRender = true;\n          break;\n        }\n\n      case 'store-or-network':\n        {\n          shouldFetch = !hasFullQuery;\n          shouldAllowRender = canPartialRender;\n          break;\n        }\n\n      case 'store-and-network':\n        {\n          shouldFetch = true;\n          shouldAllowRender = canPartialRender;\n          break;\n        }\n\n      case 'network-only':\n      default:\n        {\n          shouldFetch = true;\n          shouldAllowRender = false;\n          break;\n        }\n    } // NOTE: If this value is false, we will cache a promise for this\n    // query, which means we will suspend here at this query root.\n    // If it's true, we will cache the query resource and allow rendering to\n    // continue.\n\n\n    if (shouldAllowRender) {\n      var queryResult = getQueryResult(operation, cacheIdentifier);\n\n      var _cacheEntry = createCacheEntry(cacheIdentifier, operation, queryAvailability, queryResult, null, this._clearCacheEntry);\n\n      this._cache.set(cacheIdentifier, _cacheEntry);\n    }\n\n    if (shouldFetch) {\n      var _queryResult = getQueryResult(operation, cacheIdentifier);\n\n      var networkSubscription;\n      fetchObservable.subscribe({\n        start: function start(subscription) {\n          networkSubscription = subscription;\n\n          var cacheEntry = _this2._cache.get(cacheIdentifier);\n\n          if (cacheEntry) {\n            cacheEntry.setNetworkSubscription(networkSubscription);\n          }\n\n          var observerStart = observer === null || observer === void 0 ? void 0 : observer.start;\n\n          if (observerStart) {\n            var subscriptionWithConditionalCancelation = (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, subscription), {}, {\n              unsubscribe: function unsubscribe() {\n                // Only live queries should have their network requests canceled.\n                if (operationIsLiveQuery(operation)) {\n                  subscription.unsubscribe();\n                }\n              }\n            });\n            observerStart(subscriptionWithConditionalCancelation);\n          }\n        },\n        next: function next() {\n          var cacheEntry = _this2._getOrCreateCacheEntry(cacheIdentifier, operation, queryAvailability, _queryResult, networkSubscription);\n\n          cacheEntry.processedPayloadsCount += 1;\n          cacheEntry.setValue(_queryResult);\n          resolveNetworkPromise();\n          var observerNext = observer === null || observer === void 0 ? void 0 : observer.next;\n\n          if (observerNext != null) {\n            var snapshot = environment.lookup(operation.fragment);\n            observerNext(snapshot);\n          }\n        },\n        error: function error(_error) {\n          var cacheEntry = _this2._getOrCreateCacheEntry(cacheIdentifier, operation, queryAvailability, _error, networkSubscription); // If, this is the first thing we receive for the query,\n          // before any other payload handled is error, we will cache and\n          // re-throw that error later.\n          // We will ignore errors for any incremental payloads we receive.\n\n\n          if (cacheEntry.processedPayloadsCount === 0) {\n            cacheEntry.setValue(_error);\n          } else {\n            // TODO:T92030819 Remove this warning and actually throw the network error\n            // To complete this task we need to have a way of precisely tracking suspendable points\n            process.env.NODE_ENV !== \"production\" ? warning(false, 'QueryResource: An incremental payload for query `%` returned an error: `%`:`%`.', operation.fragment.node.name, _error.message, _error.stack) : void 0;\n          }\n\n          resolveNetworkPromise();\n          networkSubscription = null;\n          cacheEntry.setNetworkSubscription(null);\n          var observerError = observer === null || observer === void 0 ? void 0 : observer.error;\n          observerError && observerError(_error);\n        },\n        complete: function complete() {\n          resolveNetworkPromise();\n          networkSubscription = null;\n\n          var cacheEntry = _this2._cache.get(cacheIdentifier);\n\n          if (cacheEntry) {\n            cacheEntry.setNetworkSubscription(null);\n          }\n\n          var observerComplete = observer === null || observer === void 0 ? void 0 : observer.complete;\n          observerComplete && observerComplete();\n        },\n        unsubscribe: observer === null || observer === void 0 ? void 0 : observer.unsubscribe\n      });\n\n      var _cacheEntry2 = this._cache.get(cacheIdentifier);\n\n      if (!_cacheEntry2) {\n        var networkPromise = new Promise(function (resolve) {\n          resolveNetworkPromise = resolve;\n        }); // $FlowExpectedError[prop-missing] Expando to annotate Promises.\n\n        networkPromise.displayName = 'Relay(' + operation.fragment.node.name + ')';\n        _cacheEntry2 = createCacheEntry(cacheIdentifier, operation, queryAvailability, networkPromise, networkSubscription, this._clearCacheEntry);\n\n        this._cache.set(cacheIdentifier, _cacheEntry2);\n      }\n    } else {\n      var observerComplete = observer === null || observer === void 0 ? void 0 : observer.complete;\n      observerComplete && observerComplete();\n    }\n\n    var cacheEntry = this._cache.get(cacheIdentifier);\n\n    !(cacheEntry != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected to have cached a result when attempting to fetch query.' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0;\n\n    environment.__log({\n      name: 'queryresource.fetch',\n      resourceID: cacheEntry.id,\n      operation: operation,\n      profilerContext: profilerContext,\n      fetchPolicy: fetchPolicy,\n      renderPolicy: renderPolicy,\n      queryAvailability: queryAvailability,\n      shouldFetch: shouldFetch\n    });\n\n    return cacheEntry;\n  };\n\n  return QueryResourceImpl;\n}();\n\nfunction createQueryResource(environment) {\n  return new QueryResourceImpl(environment);\n}\n\nvar dataResources = WEAKMAP_SUPPORTED ? new WeakMap() : new Map();\n\nfunction getQueryResourceForEnvironment(environment) {\n  var cached = dataResources.get(environment);\n\n  if (cached) {\n    return cached;\n  }\n\n  var newDataResource = createQueryResource(environment);\n  dataResources.set(environment, newDataResource);\n  return newDataResource;\n}\n\nmodule.exports = {\n  createQueryResource: createQueryResource,\n  getQueryResourceForEnvironment: getQueryResourceForEnvironment,\n  getQueryCacheIdentifier: getQueryCacheIdentifier\n};"]},"metadata":{},"sourceType":"script"}