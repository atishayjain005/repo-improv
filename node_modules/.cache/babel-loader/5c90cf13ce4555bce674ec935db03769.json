{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar invariant = require('invariant');\n\nvar _require = require('./RelayStoreUtils'),\n    getArgumentValues = _require.getArgumentValues;\n/**\n * Determines the variables that are in scope for a fragment given the variables\n * in scope at the root query as well as any arguments applied at the fragment\n * spread via `@arguments`.\n *\n * Note that this is analagous to determining function arguments given a function call.\n */\n\n\nfunction getFragmentVariables(fragment, rootVariables, argumentVariables) {\n  var variables;\n  fragment.argumentDefinitions.forEach(function (definition) {\n    if (argumentVariables.hasOwnProperty(definition.name)) {\n      return;\n    } // $FlowFixMe[cannot-spread-interface]\n\n\n    variables = variables || (0, _objectSpread2[\"default\"])({}, argumentVariables);\n\n    switch (definition.kind) {\n      case 'LocalArgument':\n        variables[definition.name] = definition.defaultValue;\n        break;\n\n      case 'RootArgument':\n        if (!rootVariables.hasOwnProperty(definition.name)) {\n          /*\n           * Global variables passed as values of @arguments are not required to\n           * be declared unless they are used by the callee fragment or a\n           * descendant. In this case, the root variable may not be defined when\n           * resolving the callee's variables. The value is explicitly set to\n           * undefined to conform to the check in\n           * RelayStoreUtils.getStableVariableValue() that variable keys are all\n           * present.\n           */\n          // $FlowFixMe[incompatible-use]\n          variables[definition.name] = undefined;\n          break;\n        } // $FlowFixMe[incompatible-use]\n        // $FlowFixMe[cannot-write]\n\n\n        variables[definition.name] = rootVariables[definition.name];\n        break;\n\n      default:\n        definition;\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayConcreteVariables: Unexpected node kind `%s` in fragment `%s`.', definition.kind, fragment.name) : invariant(false) : void 0;\n    }\n  });\n  return variables || argumentVariables;\n}\n/**\n * Determines the variables that are in scope for a given operation given values\n * for some/all of its arguments. Extraneous input variables are filtered from\n * the output, and missing variables are set to default values (if given in the\n * operation's definition).\n */\n\n\nfunction getOperationVariables(operation, variables) {\n  var operationVariables = {};\n  operation.argumentDefinitions.forEach(function (def) {\n    var value = def.defaultValue; // $FlowFixMe[cannot-write]\n\n    if (variables[def.name] != null) {\n      value = variables[def.name];\n    }\n\n    operationVariables[def.name] = value;\n  });\n  return operationVariables;\n}\n\nfunction getLocalVariables(currentVariables, argumentDefinitions, args) {\n  if (argumentDefinitions == null) {\n    return currentVariables;\n  }\n\n  var nextVariables = (0, _objectSpread2[\"default\"])({}, currentVariables);\n  var nextArgs = args ? getArgumentValues(args, currentVariables) : {};\n  argumentDefinitions.forEach(function (def) {\n    var _nextArgs$def$name; // $FlowFixMe[cannot-write]\n\n\n    var value = (_nextArgs$def$name = nextArgs[def.name]) !== null && _nextArgs$def$name !== void 0 ? _nextArgs$def$name : def.defaultValue;\n    nextVariables[def.name] = value;\n  });\n  return nextVariables;\n}\n\nmodule.exports = {\n  getLocalVariables: getLocalVariables,\n  getFragmentVariables: getFragmentVariables,\n  getOperationVariables: getOperationVariables\n};","map":{"version":3,"sources":["/home/akshay/Atishay/appointy-screening/node_modules/relay-runtime/lib/store/RelayConcreteVariables.js"],"names":["_interopRequireDefault","require","_objectSpread2","invariant","_require","getArgumentValues","getFragmentVariables","fragment","rootVariables","argumentVariables","variables","argumentDefinitions","forEach","definition","hasOwnProperty","name","kind","defaultValue","undefined","process","env","NODE_ENV","getOperationVariables","operation","operationVariables","def","value","getLocalVariables","currentVariables","args","nextVariables","nextArgs","_nextArgs$def$name","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar invariant = require('invariant');\n\nvar _require = require('./RelayStoreUtils'),\n    getArgumentValues = _require.getArgumentValues;\n\n/**\n * Determines the variables that are in scope for a fragment given the variables\n * in scope at the root query as well as any arguments applied at the fragment\n * spread via `@arguments`.\n *\n * Note that this is analagous to determining function arguments given a function call.\n */\nfunction getFragmentVariables(fragment, rootVariables, argumentVariables) {\n  var variables;\n  fragment.argumentDefinitions.forEach(function (definition) {\n    if (argumentVariables.hasOwnProperty(definition.name)) {\n      return;\n    } // $FlowFixMe[cannot-spread-interface]\n\n\n    variables = variables || (0, _objectSpread2[\"default\"])({}, argumentVariables);\n\n    switch (definition.kind) {\n      case 'LocalArgument':\n        variables[definition.name] = definition.defaultValue;\n        break;\n\n      case 'RootArgument':\n        if (!rootVariables.hasOwnProperty(definition.name)) {\n          /*\n           * Global variables passed as values of @arguments are not required to\n           * be declared unless they are used by the callee fragment or a\n           * descendant. In this case, the root variable may not be defined when\n           * resolving the callee's variables. The value is explicitly set to\n           * undefined to conform to the check in\n           * RelayStoreUtils.getStableVariableValue() that variable keys are all\n           * present.\n           */\n          // $FlowFixMe[incompatible-use]\n          variables[definition.name] = undefined;\n          break;\n        } // $FlowFixMe[incompatible-use]\n        // $FlowFixMe[cannot-write]\n\n\n        variables[definition.name] = rootVariables[definition.name];\n        break;\n\n      default:\n        definition;\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayConcreteVariables: Unexpected node kind `%s` in fragment `%s`.', definition.kind, fragment.name) : invariant(false) : void 0;\n    }\n  });\n  return variables || argumentVariables;\n}\n/**\n * Determines the variables that are in scope for a given operation given values\n * for some/all of its arguments. Extraneous input variables are filtered from\n * the output, and missing variables are set to default values (if given in the\n * operation's definition).\n */\n\n\nfunction getOperationVariables(operation, variables) {\n  var operationVariables = {};\n  operation.argumentDefinitions.forEach(function (def) {\n    var value = def.defaultValue; // $FlowFixMe[cannot-write]\n\n    if (variables[def.name] != null) {\n      value = variables[def.name];\n    }\n\n    operationVariables[def.name] = value;\n  });\n  return operationVariables;\n}\n\nfunction getLocalVariables(currentVariables, argumentDefinitions, args) {\n  if (argumentDefinitions == null) {\n    return currentVariables;\n  }\n\n  var nextVariables = (0, _objectSpread2[\"default\"])({}, currentVariables);\n  var nextArgs = args ? getArgumentValues(args, currentVariables) : {};\n  argumentDefinitions.forEach(function (def) {\n    var _nextArgs$def$name;\n\n    // $FlowFixMe[cannot-write]\n    var value = (_nextArgs$def$name = nextArgs[def.name]) !== null && _nextArgs$def$name !== void 0 ? _nextArgs$def$name : def.defaultValue;\n    nextVariables[def.name] = value;\n  });\n  return nextVariables;\n}\n\nmodule.exports = {\n  getLocalVariables: getLocalVariables,\n  getFragmentVariables: getFragmentVariables,\n  getOperationVariables: getOperationVariables\n};"]},"metadata":{},"sourceType":"script"}