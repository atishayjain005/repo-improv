{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar recycleNodesInto = require('../util/recycleNodesInto');\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar _require = require('./ClientID'),\n    generateClientID = _require.generateClientID;\n\nvar _require2 = require('./RelayStoreUtils'),\n    RELAY_RESOLVER_VALUE_KEY = _require2.RELAY_RESOLVER_VALUE_KEY,\n    RELAY_RESOLVER_INVALIDATION_KEY = _require2.RELAY_RESOLVER_INVALIDATION_KEY,\n    RELAY_RESOLVER_INPUTS_KEY = _require2.RELAY_RESOLVER_INPUTS_KEY,\n    RELAY_RESOLVER_READER_SELECTOR_KEY = _require2.RELAY_RESOLVER_READER_SELECTOR_KEY,\n    getStorageKey = _require2.getStorageKey; // $FlowFixMe[unclear-type] - will always be empty\n\n\nvar emptySet = new Set();\n\nvar NoopResolverCache = /*#__PURE__*/function () {\n  function NoopResolverCache() {}\n\n  var _proto = NoopResolverCache.prototype;\n\n  _proto.readFromCacheOrEvaluate = function readFromCacheOrEvaluate(record, field, variables, evaluate, getDataForResolverFragment) {\n    return [evaluate().resolverResult, undefined];\n  };\n\n  _proto.invalidateDataIDs = function invalidateDataIDs(updatedDataIDs) {};\n\n  return NoopResolverCache;\n}();\n\nfunction addDependencyEdge(edges, from, to) {\n  var set = edges.get(from);\n\n  if (!set) {\n    set = new Set();\n    edges.set(from, set);\n  }\n\n  set.add(to);\n}\n\nvar RecordResolverCache = /*#__PURE__*/function () {\n  function RecordResolverCache(getRecordSource) {\n    this._resolverIDToRecordIDs = new Map();\n    this._recordIDToResolverIDs = new Map();\n    this._getRecordSource = getRecordSource;\n  }\n\n  var _proto2 = RecordResolverCache.prototype;\n\n  _proto2.readFromCacheOrEvaluate = function readFromCacheOrEvaluate(record, field, variables, evaluate, getDataForResolverFragment) {\n    var recordSource = this._getRecordSource();\n\n    var recordID = RelayModernRecord.getDataID(record);\n    var storageKey = getStorageKey(field, variables);\n    var linkedID = RelayModernRecord.getLinkedRecordID(record, storageKey);\n    var linkedRecord = linkedID == null ? null : recordSource.get(linkedID);\n\n    if (linkedRecord == null || this._isInvalid(linkedRecord, getDataForResolverFragment)) {\n      var _linkedID; // Cache miss; evaluate the selector and store the result in a new record:\n\n\n      linkedID = (_linkedID = linkedID) !== null && _linkedID !== void 0 ? _linkedID : generateClientID(recordID, storageKey);\n      linkedRecord = RelayModernRecord.create(linkedID, '__RELAY_RESOLVER__');\n      var evaluationResult = evaluate();\n      RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_VALUE_KEY, evaluationResult.resolverResult);\n      RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_INPUTS_KEY, evaluationResult.fragmentValue);\n      RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_READER_SELECTOR_KEY, evaluationResult.readerSelector);\n      recordSource.set(linkedID, linkedRecord); // Link the resolver value record to the resolver field of the record being read:\n\n      var nextRecord = RelayModernRecord.clone(record);\n      RelayModernRecord.setLinkedRecordID(nextRecord, storageKey, linkedID);\n      recordSource.set(RelayModernRecord.getDataID(nextRecord), nextRecord); // Put records observed by the resolver into the dependency graph:\n\n      var resolverID = evaluationResult.resolverID;\n      addDependencyEdge(this._resolverIDToRecordIDs, resolverID, linkedID);\n      addDependencyEdge(this._recordIDToResolverIDs, recordID, resolverID);\n\n      var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(evaluationResult.seenRecordIDs),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var seenRecordID = _step.value;\n          addDependencyEdge(this._recordIDToResolverIDs, seenRecordID, resolverID);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    } // $FlowFixMe[incompatible-type] - will always be empty\n\n\n    var answer = linkedRecord[RELAY_RESOLVER_VALUE_KEY];\n    return [answer, linkedID];\n  };\n\n  _proto2.invalidateDataIDs = function invalidateDataIDs(updatedDataIDs) {\n    var recordSource = this._getRecordSource();\n\n    var visited = new Set();\n    var recordsToVisit = Array.from(updatedDataIDs);\n\n    while (recordsToVisit.length) {\n      var recordID = recordsToVisit.pop();\n      updatedDataIDs.add(recordID);\n\n      var _iterator2 = (0, _createForOfIteratorHelper2[\"default\"])((_this$_recordIDToReso = this._recordIDToResolverIDs.get(recordID)) !== null && _this$_recordIDToReso !== void 0 ? _this$_recordIDToReso : emptySet),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _this$_recordIDToReso;\n\n          var fragment = _step2.value;\n\n          if (!visited.has(fragment)) {\n            var _iterator3 = (0, _createForOfIteratorHelper2[\"default\"])((_this$_resolverIDToRe = this._resolverIDToRecordIDs.get(fragment)) !== null && _this$_resolverIDToRe !== void 0 ? _this$_resolverIDToRe : emptySet),\n                _step3;\n\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var _this$_resolverIDToRe;\n\n                var anotherRecordID = _step3.value;\n\n                this._markInvalidatedResolverRecord(anotherRecordID, recordSource, updatedDataIDs);\n\n                if (!visited.has(anotherRecordID)) {\n                  recordsToVisit.push(anotherRecordID);\n                }\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  };\n\n  _proto2._markInvalidatedResolverRecord = function _markInvalidatedResolverRecord(dataID, recordSource, // Written to\n  updatedDataIDs) // Mutated in place\n  {\n    var record = recordSource.get(dataID);\n\n    if (!record) {\n      process.env.NODE_ENV !== \"production\" ? warning(false, 'Expected a resolver record with ID %s, but it was missing.', dataID) : void 0;\n      return;\n    }\n\n    var nextRecord = RelayModernRecord.clone(record);\n    RelayModernRecord.setValue(nextRecord, RELAY_RESOLVER_INVALIDATION_KEY, true);\n    recordSource.set(dataID, nextRecord);\n  };\n\n  _proto2._isInvalid = function _isInvalid(record, getDataForResolverFragment) {\n    if (!RelayModernRecord.getValue(record, RELAY_RESOLVER_INVALIDATION_KEY)) {\n      return false;\n    }\n\n    var originalInputs = RelayModernRecord.getValue(record, RELAY_RESOLVER_INPUTS_KEY); // $FlowFixMe[incompatible-type] - storing values in records is not typed\n\n    var readerSelector = RelayModernRecord.getValue(record, RELAY_RESOLVER_READER_SELECTOR_KEY);\n\n    if (originalInputs == null || readerSelector == null) {\n      process.env.NODE_ENV !== \"production\" ? warning(false, 'Expected previous inputs and reader selector on resolver record with ID %s, but they were missing.', RelayModernRecord.getDataID(record)) : void 0;\n      return true;\n    }\n\n    var latestValues = getDataForResolverFragment(readerSelector);\n    var recycled = recycleNodesInto(originalInputs, latestValues);\n\n    if (recycled !== originalInputs) {\n      return true;\n    }\n\n    return false;\n  };\n\n  return RecordResolverCache;\n}();\n\nmodule.exports = {\n  NoopResolverCache: NoopResolverCache,\n  RecordResolverCache: RecordResolverCache\n};","map":{"version":3,"sources":["/home/akshay/Atishay/appointy-screening/node_modules/relay-runtime/lib/store/ResolverCache.js"],"names":["_interopRequireDefault","require","_createForOfIteratorHelper2","RelayModernRecord","recycleNodesInto","warning","_require","generateClientID","_require2","RELAY_RESOLVER_VALUE_KEY","RELAY_RESOLVER_INVALIDATION_KEY","RELAY_RESOLVER_INPUTS_KEY","RELAY_RESOLVER_READER_SELECTOR_KEY","getStorageKey","emptySet","Set","NoopResolverCache","_proto","prototype","readFromCacheOrEvaluate","record","field","variables","evaluate","getDataForResolverFragment","resolverResult","undefined","invalidateDataIDs","updatedDataIDs","addDependencyEdge","edges","from","to","set","get","add","RecordResolverCache","getRecordSource","_resolverIDToRecordIDs","Map","_recordIDToResolverIDs","_getRecordSource","_proto2","recordSource","recordID","getDataID","storageKey","linkedID","getLinkedRecordID","linkedRecord","_isInvalid","_linkedID","create","evaluationResult","setValue","fragmentValue","readerSelector","nextRecord","clone","setLinkedRecordID","resolverID","_iterator","seenRecordIDs","_step","s","n","done","seenRecordID","value","err","e","f","answer","visited","recordsToVisit","Array","length","pop","_iterator2","_this$_recordIDToReso","_step2","fragment","has","_iterator3","_this$_resolverIDToRe","_step3","anotherRecordID","_markInvalidatedResolverRecord","push","dataID","process","env","NODE_ENV","getValue","originalInputs","latestValues","recycled","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _createForOfIteratorHelper2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createForOfIteratorHelper\"));\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar recycleNodesInto = require('../util/recycleNodesInto');\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar _require = require('./ClientID'),\n    generateClientID = _require.generateClientID;\n\nvar _require2 = require('./RelayStoreUtils'),\n    RELAY_RESOLVER_VALUE_KEY = _require2.RELAY_RESOLVER_VALUE_KEY,\n    RELAY_RESOLVER_INVALIDATION_KEY = _require2.RELAY_RESOLVER_INVALIDATION_KEY,\n    RELAY_RESOLVER_INPUTS_KEY = _require2.RELAY_RESOLVER_INPUTS_KEY,\n    RELAY_RESOLVER_READER_SELECTOR_KEY = _require2.RELAY_RESOLVER_READER_SELECTOR_KEY,\n    getStorageKey = _require2.getStorageKey;\n\n// $FlowFixMe[unclear-type] - will always be empty\nvar emptySet = new Set();\n\nvar NoopResolverCache = /*#__PURE__*/function () {\n  function NoopResolverCache() {}\n\n  var _proto = NoopResolverCache.prototype;\n\n  _proto.readFromCacheOrEvaluate = function readFromCacheOrEvaluate(record, field, variables, evaluate, getDataForResolverFragment) {\n    return [evaluate().resolverResult, undefined];\n  };\n\n  _proto.invalidateDataIDs = function invalidateDataIDs(updatedDataIDs) {};\n\n  return NoopResolverCache;\n}();\n\nfunction addDependencyEdge(edges, from, to) {\n  var set = edges.get(from);\n\n  if (!set) {\n    set = new Set();\n    edges.set(from, set);\n  }\n\n  set.add(to);\n}\n\nvar RecordResolverCache = /*#__PURE__*/function () {\n  function RecordResolverCache(getRecordSource) {\n    this._resolverIDToRecordIDs = new Map();\n    this._recordIDToResolverIDs = new Map();\n    this._getRecordSource = getRecordSource;\n  }\n\n  var _proto2 = RecordResolverCache.prototype;\n\n  _proto2.readFromCacheOrEvaluate = function readFromCacheOrEvaluate(record, field, variables, evaluate, getDataForResolverFragment) {\n    var recordSource = this._getRecordSource();\n\n    var recordID = RelayModernRecord.getDataID(record);\n    var storageKey = getStorageKey(field, variables);\n    var linkedID = RelayModernRecord.getLinkedRecordID(record, storageKey);\n    var linkedRecord = linkedID == null ? null : recordSource.get(linkedID);\n\n    if (linkedRecord == null || this._isInvalid(linkedRecord, getDataForResolverFragment)) {\n      var _linkedID;\n\n      // Cache miss; evaluate the selector and store the result in a new record:\n      linkedID = (_linkedID = linkedID) !== null && _linkedID !== void 0 ? _linkedID : generateClientID(recordID, storageKey);\n      linkedRecord = RelayModernRecord.create(linkedID, '__RELAY_RESOLVER__');\n      var evaluationResult = evaluate();\n      RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_VALUE_KEY, evaluationResult.resolverResult);\n      RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_INPUTS_KEY, evaluationResult.fragmentValue);\n      RelayModernRecord.setValue(linkedRecord, RELAY_RESOLVER_READER_SELECTOR_KEY, evaluationResult.readerSelector);\n      recordSource.set(linkedID, linkedRecord); // Link the resolver value record to the resolver field of the record being read:\n\n      var nextRecord = RelayModernRecord.clone(record);\n      RelayModernRecord.setLinkedRecordID(nextRecord, storageKey, linkedID);\n      recordSource.set(RelayModernRecord.getDataID(nextRecord), nextRecord); // Put records observed by the resolver into the dependency graph:\n\n      var resolverID = evaluationResult.resolverID;\n      addDependencyEdge(this._resolverIDToRecordIDs, resolverID, linkedID);\n      addDependencyEdge(this._recordIDToResolverIDs, recordID, resolverID);\n\n      var _iterator = (0, _createForOfIteratorHelper2[\"default\"])(evaluationResult.seenRecordIDs),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var seenRecordID = _step.value;\n          addDependencyEdge(this._recordIDToResolverIDs, seenRecordID, resolverID);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    } // $FlowFixMe[incompatible-type] - will always be empty\n\n\n    var answer = linkedRecord[RELAY_RESOLVER_VALUE_KEY];\n    return [answer, linkedID];\n  };\n\n  _proto2.invalidateDataIDs = function invalidateDataIDs(updatedDataIDs) {\n    var recordSource = this._getRecordSource();\n\n    var visited = new Set();\n    var recordsToVisit = Array.from(updatedDataIDs);\n\n    while (recordsToVisit.length) {\n      var recordID = recordsToVisit.pop();\n      updatedDataIDs.add(recordID);\n\n      var _iterator2 = (0, _createForOfIteratorHelper2[\"default\"])((_this$_recordIDToReso = this._recordIDToResolverIDs.get(recordID)) !== null && _this$_recordIDToReso !== void 0 ? _this$_recordIDToReso : emptySet),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _this$_recordIDToReso;\n\n          var fragment = _step2.value;\n\n          if (!visited.has(fragment)) {\n            var _iterator3 = (0, _createForOfIteratorHelper2[\"default\"])((_this$_resolverIDToRe = this._resolverIDToRecordIDs.get(fragment)) !== null && _this$_resolverIDToRe !== void 0 ? _this$_resolverIDToRe : emptySet),\n                _step3;\n\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var _this$_resolverIDToRe;\n\n                var anotherRecordID = _step3.value;\n\n                this._markInvalidatedResolverRecord(anotherRecordID, recordSource, updatedDataIDs);\n\n                if (!visited.has(anotherRecordID)) {\n                  recordsToVisit.push(anotherRecordID);\n                }\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  };\n\n  _proto2._markInvalidatedResolverRecord = function _markInvalidatedResolverRecord(dataID, recordSource, // Written to\n  updatedDataIDs) // Mutated in place\n  {\n    var record = recordSource.get(dataID);\n\n    if (!record) {\n      process.env.NODE_ENV !== \"production\" ? warning(false, 'Expected a resolver record with ID %s, but it was missing.', dataID) : void 0;\n      return;\n    }\n\n    var nextRecord = RelayModernRecord.clone(record);\n    RelayModernRecord.setValue(nextRecord, RELAY_RESOLVER_INVALIDATION_KEY, true);\n    recordSource.set(dataID, nextRecord);\n  };\n\n  _proto2._isInvalid = function _isInvalid(record, getDataForResolverFragment) {\n    if (!RelayModernRecord.getValue(record, RELAY_RESOLVER_INVALIDATION_KEY)) {\n      return false;\n    }\n\n    var originalInputs = RelayModernRecord.getValue(record, RELAY_RESOLVER_INPUTS_KEY); // $FlowFixMe[incompatible-type] - storing values in records is not typed\n\n    var readerSelector = RelayModernRecord.getValue(record, RELAY_RESOLVER_READER_SELECTOR_KEY);\n\n    if (originalInputs == null || readerSelector == null) {\n      process.env.NODE_ENV !== \"production\" ? warning(false, 'Expected previous inputs and reader selector on resolver record with ID %s, but they were missing.', RelayModernRecord.getDataID(record)) : void 0;\n      return true;\n    }\n\n    var latestValues = getDataForResolverFragment(readerSelector);\n    var recycled = recycleNodesInto(originalInputs, latestValues);\n\n    if (recycled !== originalInputs) {\n      return true;\n    }\n\n    return false;\n  };\n\n  return RecordResolverCache;\n}();\n\nmodule.exports = {\n  NoopResolverCache: NoopResolverCache,\n  RecordResolverCache: RecordResolverCache\n};"]},"metadata":{},"sourceType":"script"}