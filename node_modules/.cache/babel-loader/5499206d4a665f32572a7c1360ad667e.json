{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar RelayReader = require('./RelayReader');\n\nvar deepFreeze = require('../util/deepFreeze');\n\nvar hasOverlappingIDs = require('./hasOverlappingIDs');\n\nvar recycleNodesInto = require('../util/recycleNodesInto');\n\nvar RelayStoreSubscriptions = /*#__PURE__*/function () {\n  function RelayStoreSubscriptions(log, resolverCache) {\n    this._subscriptions = new Set();\n    this.__log = log;\n    this._resolverCache = resolverCache;\n  }\n\n  var _proto = RelayStoreSubscriptions.prototype;\n\n  _proto.subscribe = function subscribe(snapshot, callback) {\n    var _this = this;\n\n    var subscription = {\n      backup: null,\n      callback: callback,\n      snapshot: snapshot,\n      stale: false\n    };\n\n    var dispose = function dispose() {\n      _this._subscriptions[\"delete\"](subscription);\n    };\n\n    this._subscriptions.add(subscription);\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.snapshotSubscriptions = function snapshotSubscriptions(source) {\n    var _this2 = this;\n\n    this._subscriptions.forEach(function (subscription) {\n      // Backup occurs after writing a new \"final\" payload(s) and before (re)applying\n      // optimistic changes. Each subscription's `snapshot` represents what was *last\n      // published to the subscriber*, which notably may include previous optimistic\n      // updates. Therefore a subscription can be in any of the following states:\n      // - stale=true: This subscription was restored to a different value than\n      //   `snapshot`. That means this subscription has changes relative to its base,\n      //   but its base has changed (we just applied a final payload): recompute\n      //   a backup so that we can later restore to the state the subscription\n      //   should be in.\n      // - stale=false: This subscription was restored to the same value as\n      //   `snapshot`. That means this subscription does *not* have changes relative\n      //   to its base, so the current `snapshot` is valid to use as a backup.\n      if (!subscription.stale) {\n        subscription.backup = subscription.snapshot;\n        return;\n      }\n\n      var snapshot = subscription.snapshot;\n      var backup = RelayReader.read(source, snapshot.selector, _this2._resolverCache);\n      var nextData = recycleNodesInto(snapshot.data, backup.data);\n      backup.data = nextData; // backup owns the snapshot and can safely mutate\n\n      subscription.backup = backup;\n    });\n  };\n\n  _proto.restoreSubscriptions = function restoreSubscriptions() {\n    this._subscriptions.forEach(function (subscription) {\n      var backup = subscription.backup;\n      subscription.backup = null;\n\n      if (backup) {\n        if (backup.data !== subscription.snapshot.data) {\n          subscription.stale = true;\n        }\n\n        subscription.snapshot = {\n          data: subscription.snapshot.data,\n          isMissingData: backup.isMissingData,\n          seenRecords: backup.seenRecords,\n          selector: backup.selector,\n          missingRequiredFields: backup.missingRequiredFields\n        };\n      } else {\n        subscription.stale = true;\n      }\n    });\n  };\n\n  _proto.updateSubscriptions = function updateSubscriptions(source, updatedRecordIDs, updatedOwners, sourceOperation) {\n    var _this3 = this;\n\n    var hasUpdatedRecords = updatedRecordIDs.size !== 0;\n\n    this._subscriptions.forEach(function (subscription) {\n      var owner = _this3._updateSubscription(source, subscription, updatedRecordIDs, hasUpdatedRecords, sourceOperation);\n\n      if (owner != null) {\n        updatedOwners.push(owner);\n      }\n    });\n  }\n  /**\n   * Notifies the callback for the subscription if the data for the associated\n   * snapshot has changed.\n   * Additionally, updates the subscription snapshot with the latest snapshot,\n   * and marks it as not stale.\n   * Returns the owner (RequestDescriptor) if the subscription was affected by the\n   * latest update, or null if it was not affected.\n   */\n  ;\n\n  _proto._updateSubscription = function _updateSubscription(source, subscription, updatedRecordIDs, hasUpdatedRecords, sourceOperation) {\n    var backup = subscription.backup,\n        callback = subscription.callback,\n        snapshot = subscription.snapshot,\n        stale = subscription.stale;\n    var hasOverlappingUpdates = hasUpdatedRecords && hasOverlappingIDs(snapshot.seenRecords, updatedRecordIDs);\n\n    if (!stale && !hasOverlappingUpdates) {\n      return;\n    }\n\n    var nextSnapshot = hasOverlappingUpdates || !backup ? RelayReader.read(source, snapshot.selector, this._resolverCache) : backup;\n    var nextData = recycleNodesInto(snapshot.data, nextSnapshot.data);\n    nextSnapshot = {\n      data: nextData,\n      isMissingData: nextSnapshot.isMissingData,\n      seenRecords: nextSnapshot.seenRecords,\n      selector: nextSnapshot.selector,\n      missingRequiredFields: nextSnapshot.missingRequiredFields\n    };\n\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(nextSnapshot);\n    }\n\n    subscription.snapshot = nextSnapshot;\n    subscription.stale = false;\n\n    if (nextSnapshot.data !== snapshot.data) {\n      if (this.__log && RelayFeatureFlags.ENABLE_NOTIFY_SUBSCRIPTION) {\n        this.__log({\n          name: 'store.notify.subscription',\n          sourceOperation: sourceOperation,\n          snapshot: snapshot,\n          nextSnapshot: nextSnapshot\n        });\n      }\n\n      callback(nextSnapshot);\n      return snapshot.selector.owner;\n    }\n  };\n\n  return RelayStoreSubscriptions;\n}();\n\nmodule.exports = RelayStoreSubscriptions;","map":{"version":3,"sources":["/home/akshay/Atishay/appointy-screening/node_modules/relay-runtime/lib/store/RelayStoreSubscriptions.js"],"names":["RelayFeatureFlags","require","RelayReader","deepFreeze","hasOverlappingIDs","recycleNodesInto","RelayStoreSubscriptions","log","resolverCache","_subscriptions","Set","__log","_resolverCache","_proto","prototype","subscribe","snapshot","callback","_this","subscription","backup","stale","dispose","add","snapshotSubscriptions","source","_this2","forEach","read","selector","nextData","data","restoreSubscriptions","isMissingData","seenRecords","missingRequiredFields","updateSubscriptions","updatedRecordIDs","updatedOwners","sourceOperation","_this3","hasUpdatedRecords","size","owner","_updateSubscription","push","hasOverlappingUpdates","nextSnapshot","process","env","NODE_ENV","ENABLE_NOTIFY_SUBSCRIPTION","name","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar RelayReader = require('./RelayReader');\n\nvar deepFreeze = require('../util/deepFreeze');\n\nvar hasOverlappingIDs = require('./hasOverlappingIDs');\n\nvar recycleNodesInto = require('../util/recycleNodesInto');\n\nvar RelayStoreSubscriptions = /*#__PURE__*/function () {\n  function RelayStoreSubscriptions(log, resolverCache) {\n    this._subscriptions = new Set();\n    this.__log = log;\n    this._resolverCache = resolverCache;\n  }\n\n  var _proto = RelayStoreSubscriptions.prototype;\n\n  _proto.subscribe = function subscribe(snapshot, callback) {\n    var _this = this;\n\n    var subscription = {\n      backup: null,\n      callback: callback,\n      snapshot: snapshot,\n      stale: false\n    };\n\n    var dispose = function dispose() {\n      _this._subscriptions[\"delete\"](subscription);\n    };\n\n    this._subscriptions.add(subscription);\n\n    return {\n      dispose: dispose\n    };\n  };\n\n  _proto.snapshotSubscriptions = function snapshotSubscriptions(source) {\n    var _this2 = this;\n\n    this._subscriptions.forEach(function (subscription) {\n      // Backup occurs after writing a new \"final\" payload(s) and before (re)applying\n      // optimistic changes. Each subscription's `snapshot` represents what was *last\n      // published to the subscriber*, which notably may include previous optimistic\n      // updates. Therefore a subscription can be in any of the following states:\n      // - stale=true: This subscription was restored to a different value than\n      //   `snapshot`. That means this subscription has changes relative to its base,\n      //   but its base has changed (we just applied a final payload): recompute\n      //   a backup so that we can later restore to the state the subscription\n      //   should be in.\n      // - stale=false: This subscription was restored to the same value as\n      //   `snapshot`. That means this subscription does *not* have changes relative\n      //   to its base, so the current `snapshot` is valid to use as a backup.\n      if (!subscription.stale) {\n        subscription.backup = subscription.snapshot;\n        return;\n      }\n\n      var snapshot = subscription.snapshot;\n      var backup = RelayReader.read(source, snapshot.selector, _this2._resolverCache);\n      var nextData = recycleNodesInto(snapshot.data, backup.data);\n      backup.data = nextData; // backup owns the snapshot and can safely mutate\n\n      subscription.backup = backup;\n    });\n  };\n\n  _proto.restoreSubscriptions = function restoreSubscriptions() {\n    this._subscriptions.forEach(function (subscription) {\n      var backup = subscription.backup;\n      subscription.backup = null;\n\n      if (backup) {\n        if (backup.data !== subscription.snapshot.data) {\n          subscription.stale = true;\n        }\n\n        subscription.snapshot = {\n          data: subscription.snapshot.data,\n          isMissingData: backup.isMissingData,\n          seenRecords: backup.seenRecords,\n          selector: backup.selector,\n          missingRequiredFields: backup.missingRequiredFields\n        };\n      } else {\n        subscription.stale = true;\n      }\n    });\n  };\n\n  _proto.updateSubscriptions = function updateSubscriptions(source, updatedRecordIDs, updatedOwners, sourceOperation) {\n    var _this3 = this;\n\n    var hasUpdatedRecords = updatedRecordIDs.size !== 0;\n\n    this._subscriptions.forEach(function (subscription) {\n      var owner = _this3._updateSubscription(source, subscription, updatedRecordIDs, hasUpdatedRecords, sourceOperation);\n\n      if (owner != null) {\n        updatedOwners.push(owner);\n      }\n    });\n  }\n  /**\n   * Notifies the callback for the subscription if the data for the associated\n   * snapshot has changed.\n   * Additionally, updates the subscription snapshot with the latest snapshot,\n   * and marks it as not stale.\n   * Returns the owner (RequestDescriptor) if the subscription was affected by the\n   * latest update, or null if it was not affected.\n   */\n  ;\n\n  _proto._updateSubscription = function _updateSubscription(source, subscription, updatedRecordIDs, hasUpdatedRecords, sourceOperation) {\n    var backup = subscription.backup,\n        callback = subscription.callback,\n        snapshot = subscription.snapshot,\n        stale = subscription.stale;\n    var hasOverlappingUpdates = hasUpdatedRecords && hasOverlappingIDs(snapshot.seenRecords, updatedRecordIDs);\n\n    if (!stale && !hasOverlappingUpdates) {\n      return;\n    }\n\n    var nextSnapshot = hasOverlappingUpdates || !backup ? RelayReader.read(source, snapshot.selector, this._resolverCache) : backup;\n    var nextData = recycleNodesInto(snapshot.data, nextSnapshot.data);\n    nextSnapshot = {\n      data: nextData,\n      isMissingData: nextSnapshot.isMissingData,\n      seenRecords: nextSnapshot.seenRecords,\n      selector: nextSnapshot.selector,\n      missingRequiredFields: nextSnapshot.missingRequiredFields\n    };\n\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(nextSnapshot);\n    }\n\n    subscription.snapshot = nextSnapshot;\n    subscription.stale = false;\n\n    if (nextSnapshot.data !== snapshot.data) {\n      if (this.__log && RelayFeatureFlags.ENABLE_NOTIFY_SUBSCRIPTION) {\n        this.__log({\n          name: 'store.notify.subscription',\n          sourceOperation: sourceOperation,\n          snapshot: snapshot,\n          nextSnapshot: nextSnapshot\n        });\n      }\n\n      callback(nextSnapshot);\n      return snapshot.selector.owner;\n    }\n  };\n\n  return RelayStoreSubscriptions;\n}();\n\nmodule.exports = RelayStoreSubscriptions;"]},"metadata":{},"sourceType":"script"}