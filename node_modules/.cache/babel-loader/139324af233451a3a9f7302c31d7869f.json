{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar React = require('react');\n\nvar ReactRelayContext = require('./ReactRelayContext');\n\nvar ReactRelayQueryFetcher = require('./ReactRelayQueryFetcher');\n\nvar ReactRelayQueryRendererContext = require('./ReactRelayQueryRendererContext');\n\nvar areEqual = require(\"fbjs/lib/areEqual\");\n\nvar _require = require('relay-runtime'),\n    createOperationDescriptor = _require.createOperationDescriptor,\n    deepFreeze = _require.deepFreeze,\n    getRequest = _require.getRequest,\n    RelayFeatureFlags = _require.RelayFeatureFlags;\n/**\n * React may double-fire the constructor, and we call 'fetch' in the\n * constructor. If a request is already in flight from a previous call to the\n * constructor, just reuse the query fetcher and wait for the response.\n */\n\n\nvar requestCache = {};\nvar queryRendererContext = {\n  rootIsQueryRenderer: true\n};\n/**\n * @public\n *\n * Orchestrates fetching and rendering data for a single view or view hierarchy:\n * - Fetches the query/variables using the given network implementation.\n * - Normalizes the response(s) to that query, publishing them to the given\n *   store.\n * - Renders the pending/fail/success states with the provided render function.\n * - Subscribes for updates to the root data and re-renders with any changes.\n */\n\nvar ReactRelayQueryRenderer = /*#__PURE__*/function (_React$Component) {\n  (0, _inheritsLoose2[\"default\"])(ReactRelayQueryRenderer, _React$Component);\n\n  function ReactRelayQueryRenderer(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this; // Callbacks are attached to the current instance and shared with static\n    // lifecyles by bundling with state. This is okay to do because the\n    // callbacks don't change in reaction to props. However we should not\n    // \"leak\" them before mounting (since we would be unable to clean up). For\n    // that reason, we define them as null initially and fill them in after\n    // mounting to avoid leaking memory.\n\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_handleDataChange\", function (params) {\n      var error = params.error == null ? null : params.error;\n      var snapshot = params.snapshot == null ? null : params.snapshot;\n\n      _this.setState(function (prevState) {\n        var prevRequestCacheKey = prevState.requestCacheKey;\n\n        if (prevRequestCacheKey) {\n          delete requestCache[prevRequestCacheKey];\n        } // Don't update state if nothing has changed.\n\n\n        if (snapshot === prevState.snapshot && error === prevState.error) {\n          return null;\n        }\n\n        return {\n          renderProps: getRenderProps(error, snapshot, prevState.queryFetcher, prevState.retryCallbacks),\n          snapshot: snapshot,\n          requestCacheKey: null\n        };\n      });\n    });\n    var retryCallbacks = {\n      handleDataChange: null,\n      handleRetryAfterError: null\n    };\n    var queryFetcher;\n    var requestCacheKey;\n\n    if (props.query) {\n      var query = props.query;\n      var request = getRequest(query);\n      requestCacheKey = getRequestCacheKey(request.params, props.variables);\n      queryFetcher = requestCache[requestCacheKey] ? requestCache[requestCacheKey].queryFetcher : new ReactRelayQueryFetcher();\n    } else {\n      queryFetcher = new ReactRelayQueryFetcher();\n    }\n\n    _this._maybeHiddenOrFastRefresh = false;\n    _this.state = (0, _objectSpread2[\"default\"])({\n      prevPropsEnvironment: props.environment,\n      prevPropsVariables: props.variables,\n      prevQuery: props.query,\n      queryFetcher: queryFetcher,\n      retryCallbacks: retryCallbacks\n    }, fetchQueryAndComputeStateFromProps(props, queryFetcher, retryCallbacks, requestCacheKey));\n    return _this;\n  }\n\n  ReactRelayQueryRenderer.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n    if (prevState.prevQuery !== nextProps.query || prevState.prevPropsEnvironment !== nextProps.environment || !areEqual(prevState.prevPropsVariables, nextProps.variables)) {\n      return resetQueryStateForUpdate(nextProps, prevState);\n    }\n\n    return null;\n  };\n\n  var _proto = ReactRelayQueryRenderer.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    var _this2 = this;\n\n    if (RelayFeatureFlags.ENABLE_QUERY_RENDERER_OFFSCREEN_SUPPORT === true && this._maybeHiddenOrFastRefresh === true) {\n      // This block only runs if the component has previously \"unmounted\"\n      // due to it being hidden by the Offscreen API, or during fast refresh.\n      // At this point, the current cached resource will have been disposed\n      // by the previous cleanup, so instead of attempting to\n      // do our regular commit setup, so that the query is re-evaluated\n      // (and potentially cause a refetch).\n      this._maybeHiddenOrFastRefresh = false; // eslint-disable-next-line react/no-did-mount-set-state\n\n      this.setState(function (prevState) {\n        return resetQueryStateForUpdate(_this2.props, prevState);\n      });\n      return;\n    }\n\n    var _this$state = this.state,\n        retryCallbacks = _this$state.retryCallbacks,\n        queryFetcher = _this$state.queryFetcher,\n        requestCacheKey = _this$state.requestCacheKey; // We don't need to cache the request after the component commits\n\n    if (requestCacheKey) {\n      delete requestCache[requestCacheKey];\n    }\n\n    retryCallbacks.handleDataChange = this._handleDataChange;\n\n    retryCallbacks.handleRetryAfterError = function (error) {\n      return _this2.setState(function (prevState) {\n        var prevRequestCacheKey = prevState.requestCacheKey;\n\n        if (prevRequestCacheKey) {\n          delete requestCache[prevRequestCacheKey];\n        }\n\n        return {\n          renderProps: getLoadingRenderProps(),\n          requestCacheKey: null\n        };\n      });\n    }; // Re-initialize the ReactRelayQueryFetcher with callbacks.\n    // If data has changed since constructions, this will re-render.\n\n\n    if (this.props.query) {\n      queryFetcher.setOnDataChange(this._handleDataChange);\n    }\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(_prevProps, prevState) {\n    // We don't need to cache the request after the component commits\n    var _this$state2 = this.state,\n        queryFetcher = _this$state2.queryFetcher,\n        requestCacheKey = _this$state2.requestCacheKey;\n\n    if (requestCacheKey) {\n      delete requestCache[requestCacheKey]; // HACK\n\n      delete this.state.requestCacheKey;\n    }\n\n    if (this.props.query && queryFetcher !== prevState.queryFetcher) {\n      queryFetcher.setOnDataChange(this._handleDataChange);\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.state.queryFetcher.dispose();\n    this._maybeHiddenOrFastRefresh = true;\n  };\n\n  _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {\n    return nextProps.render !== this.props.render || nextState.renderProps !== this.state.renderProps;\n  };\n\n  _proto.render = function render() {\n    var _this$state3 = this.state,\n        renderProps = _this$state3.renderProps,\n        relayContext = _this$state3.relayContext; // Note that the root fragment results in `renderProps.props` is already\n    // frozen by the store; this call is to freeze the renderProps object and\n    // error property if set.\n\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(renderProps);\n    }\n\n    return /*#__PURE__*/React.createElement(ReactRelayContext.Provider, {\n      value: relayContext\n    }, /*#__PURE__*/React.createElement(ReactRelayQueryRendererContext.Provider, {\n      value: queryRendererContext\n    }, this.props.render(renderProps)));\n  };\n\n  return ReactRelayQueryRenderer;\n}(React.Component);\n\nfunction getLoadingRenderProps() {\n  return {\n    error: null,\n    props: null,\n    // `props: null` indicates that the data is being fetched (i.e. loading)\n    retry: null\n  };\n}\n\nfunction getEmptyRenderProps() {\n  return {\n    error: null,\n    props: {},\n    // `props: {}` indicates no data available\n    retry: null\n  };\n}\n\nfunction getRenderProps(error, snapshot, queryFetcher, retryCallbacks) {\n  return {\n    error: error ? error : null,\n    props: snapshot ? snapshot.data : null,\n    retry: function retry(cacheConfigOverride) {\n      var syncSnapshot = queryFetcher.retry(cacheConfigOverride);\n\n      if (syncSnapshot && typeof retryCallbacks.handleDataChange === 'function') {\n        retryCallbacks.handleDataChange({\n          snapshot: syncSnapshot\n        });\n      } else if (error && typeof retryCallbacks.handleRetryAfterError === 'function') {\n        // If retrying after an error and no synchronous result available,\n        // reset the render props\n        retryCallbacks.handleRetryAfterError(error);\n      }\n    }\n  };\n}\n\nfunction getRequestCacheKey(request, variables) {\n  return JSON.stringify({\n    id: request.cacheID ? request.cacheID : request.id,\n    variables: variables\n  });\n}\n\nfunction resetQueryStateForUpdate(props, prevState) {\n  var query = props.query;\n  var prevSelectionReferences = prevState.queryFetcher.getSelectionReferences();\n  prevState.queryFetcher.disposeRequest();\n  var queryFetcher;\n\n  if (query) {\n    var request = getRequest(query);\n    var requestCacheKey = getRequestCacheKey(request.params, props.variables);\n    queryFetcher = requestCache[requestCacheKey] ? requestCache[requestCacheKey].queryFetcher : new ReactRelayQueryFetcher(prevSelectionReferences);\n  } else {\n    queryFetcher = new ReactRelayQueryFetcher(prevSelectionReferences);\n  }\n\n  return (0, _objectSpread2[\"default\"])({\n    prevQuery: props.query,\n    prevPropsEnvironment: props.environment,\n    prevPropsVariables: props.variables,\n    queryFetcher: queryFetcher\n  }, fetchQueryAndComputeStateFromProps(props, queryFetcher, prevState.retryCallbacks // passing no requestCacheKey will cause it to be recalculated internally\n  // and we want the updated requestCacheKey, since variables may have changed\n  ));\n}\n\nfunction fetchQueryAndComputeStateFromProps(props, queryFetcher, retryCallbacks, requestCacheKey) {\n  var environment = props.environment,\n      query = props.query,\n      variables = props.variables,\n      cacheConfig = props.cacheConfig;\n  var genericEnvironment = environment;\n\n  if (query) {\n    var request = getRequest(query);\n    var operation = createOperationDescriptor(request, variables, cacheConfig);\n    var relayContext = {\n      environment: genericEnvironment\n    };\n\n    if (typeof requestCacheKey === 'string' && requestCache[requestCacheKey]) {\n      // This same request is already in flight.\n      var snapshot = requestCache[requestCacheKey].snapshot;\n\n      if (snapshot) {\n        // Use the cached response\n        return {\n          error: null,\n          relayContext: relayContext,\n          renderProps: getRenderProps(null, snapshot, queryFetcher, retryCallbacks),\n          snapshot: snapshot,\n          requestCacheKey: requestCacheKey\n        };\n      } else {\n        // Render loading state\n        return {\n          error: null,\n          relayContext: relayContext,\n          renderProps: getLoadingRenderProps(),\n          snapshot: null,\n          requestCacheKey: requestCacheKey\n        };\n      }\n    }\n\n    try {\n      var storeSnapshot = queryFetcher.lookupInStore(genericEnvironment, operation, props.fetchPolicy);\n      var querySnapshot = queryFetcher.fetch({\n        environment: genericEnvironment,\n        onDataChange: null,\n        operation: operation\n      }); // Use network data first, since it may be fresher\n\n      var _snapshot = querySnapshot || storeSnapshot; // cache the request to avoid duplicate requests\n\n\n      requestCacheKey = requestCacheKey || getRequestCacheKey(request.params, props.variables);\n      requestCache[requestCacheKey] = {\n        queryFetcher: queryFetcher,\n        snapshot: _snapshot\n      };\n\n      if (!_snapshot) {\n        return {\n          error: null,\n          relayContext: relayContext,\n          renderProps: getLoadingRenderProps(),\n          snapshot: null,\n          requestCacheKey: requestCacheKey\n        };\n      }\n\n      return {\n        error: null,\n        relayContext: relayContext,\n        renderProps: getRenderProps(null, _snapshot, queryFetcher, retryCallbacks),\n        snapshot: _snapshot,\n        requestCacheKey: requestCacheKey\n      };\n    } catch (error) {\n      return {\n        error: error,\n        relayContext: relayContext,\n        renderProps: getRenderProps(error, null, queryFetcher, retryCallbacks),\n        snapshot: null,\n        requestCacheKey: requestCacheKey\n      };\n    }\n  } else {\n    queryFetcher.dispose();\n    var _relayContext = {\n      environment: genericEnvironment\n    };\n    return {\n      error: null,\n      relayContext: _relayContext,\n      renderProps: getEmptyRenderProps(),\n      requestCacheKey: null // if there is an error, don't cache request\n\n    };\n  }\n}\n\nmodule.exports = ReactRelayQueryRenderer;","map":{"version":3,"sources":["/home/akshay/Atishay/appointy-screening/node_modules/react-relay/lib/ReactRelayQueryRenderer.js"],"names":["_interopRequireDefault","require","_objectSpread2","_assertThisInitialized2","_inheritsLoose2","_defineProperty2","React","ReactRelayContext","ReactRelayQueryFetcher","ReactRelayQueryRendererContext","areEqual","_require","createOperationDescriptor","deepFreeze","getRequest","RelayFeatureFlags","requestCache","queryRendererContext","rootIsQueryRenderer","ReactRelayQueryRenderer","_React$Component","props","_this","call","params","error","snapshot","setState","prevState","prevRequestCacheKey","requestCacheKey","renderProps","getRenderProps","queryFetcher","retryCallbacks","handleDataChange","handleRetryAfterError","query","request","getRequestCacheKey","variables","_maybeHiddenOrFastRefresh","state","prevPropsEnvironment","environment","prevPropsVariables","prevQuery","fetchQueryAndComputeStateFromProps","getDerivedStateFromProps","nextProps","resetQueryStateForUpdate","_proto","prototype","componentDidMount","_this2","ENABLE_QUERY_RENDERER_OFFSCREEN_SUPPORT","_this$state","_handleDataChange","getLoadingRenderProps","setOnDataChange","componentDidUpdate","_prevProps","_this$state2","componentWillUnmount","dispose","shouldComponentUpdate","nextState","render","_this$state3","relayContext","process","env","NODE_ENV","createElement","Provider","value","Component","retry","getEmptyRenderProps","data","cacheConfigOverride","syncSnapshot","JSON","stringify","id","cacheID","prevSelectionReferences","getSelectionReferences","disposeRequest","cacheConfig","genericEnvironment","operation","storeSnapshot","lookupInStore","fetchPolicy","querySnapshot","fetch","onDataChange","_snapshot","_relayContext","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar React = require('react');\n\nvar ReactRelayContext = require('./ReactRelayContext');\n\nvar ReactRelayQueryFetcher = require('./ReactRelayQueryFetcher');\n\nvar ReactRelayQueryRendererContext = require('./ReactRelayQueryRendererContext');\n\nvar areEqual = require(\"fbjs/lib/areEqual\");\n\nvar _require = require('relay-runtime'),\n    createOperationDescriptor = _require.createOperationDescriptor,\n    deepFreeze = _require.deepFreeze,\n    getRequest = _require.getRequest,\n    RelayFeatureFlags = _require.RelayFeatureFlags;\n\n/**\n * React may double-fire the constructor, and we call 'fetch' in the\n * constructor. If a request is already in flight from a previous call to the\n * constructor, just reuse the query fetcher and wait for the response.\n */\nvar requestCache = {};\nvar queryRendererContext = {\n  rootIsQueryRenderer: true\n};\n\n/**\n * @public\n *\n * Orchestrates fetching and rendering data for a single view or view hierarchy:\n * - Fetches the query/variables using the given network implementation.\n * - Normalizes the response(s) to that query, publishing them to the given\n *   store.\n * - Renders the pending/fail/success states with the provided render function.\n * - Subscribes for updates to the root data and re-renders with any changes.\n */\nvar ReactRelayQueryRenderer = /*#__PURE__*/function (_React$Component) {\n  (0, _inheritsLoose2[\"default\"])(ReactRelayQueryRenderer, _React$Component);\n\n  function ReactRelayQueryRenderer(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this; // Callbacks are attached to the current instance and shared with static\n    // lifecyles by bundling with state. This is okay to do because the\n    // callbacks don't change in reaction to props. However we should not\n    // \"leak\" them before mounting (since we would be unable to clean up). For\n    // that reason, we define them as null initially and fill them in after\n    // mounting to avoid leaking memory.\n\n    (0, _defineProperty2[\"default\"])((0, _assertThisInitialized2[\"default\"])(_this), \"_handleDataChange\", function (params) {\n      var error = params.error == null ? null : params.error;\n      var snapshot = params.snapshot == null ? null : params.snapshot;\n\n      _this.setState(function (prevState) {\n        var prevRequestCacheKey = prevState.requestCacheKey;\n\n        if (prevRequestCacheKey) {\n          delete requestCache[prevRequestCacheKey];\n        } // Don't update state if nothing has changed.\n\n\n        if (snapshot === prevState.snapshot && error === prevState.error) {\n          return null;\n        }\n\n        return {\n          renderProps: getRenderProps(error, snapshot, prevState.queryFetcher, prevState.retryCallbacks),\n          snapshot: snapshot,\n          requestCacheKey: null\n        };\n      });\n    });\n    var retryCallbacks = {\n      handleDataChange: null,\n      handleRetryAfterError: null\n    };\n    var queryFetcher;\n    var requestCacheKey;\n\n    if (props.query) {\n      var query = props.query;\n      var request = getRequest(query);\n      requestCacheKey = getRequestCacheKey(request.params, props.variables);\n      queryFetcher = requestCache[requestCacheKey] ? requestCache[requestCacheKey].queryFetcher : new ReactRelayQueryFetcher();\n    } else {\n      queryFetcher = new ReactRelayQueryFetcher();\n    }\n\n    _this._maybeHiddenOrFastRefresh = false;\n    _this.state = (0, _objectSpread2[\"default\"])({\n      prevPropsEnvironment: props.environment,\n      prevPropsVariables: props.variables,\n      prevQuery: props.query,\n      queryFetcher: queryFetcher,\n      retryCallbacks: retryCallbacks\n    }, fetchQueryAndComputeStateFromProps(props, queryFetcher, retryCallbacks, requestCacheKey));\n    return _this;\n  }\n\n  ReactRelayQueryRenderer.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n    if (prevState.prevQuery !== nextProps.query || prevState.prevPropsEnvironment !== nextProps.environment || !areEqual(prevState.prevPropsVariables, nextProps.variables)) {\n      return resetQueryStateForUpdate(nextProps, prevState);\n    }\n\n    return null;\n  };\n\n  var _proto = ReactRelayQueryRenderer.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    var _this2 = this;\n\n    if (RelayFeatureFlags.ENABLE_QUERY_RENDERER_OFFSCREEN_SUPPORT === true && this._maybeHiddenOrFastRefresh === true) {\n      // This block only runs if the component has previously \"unmounted\"\n      // due to it being hidden by the Offscreen API, or during fast refresh.\n      // At this point, the current cached resource will have been disposed\n      // by the previous cleanup, so instead of attempting to\n      // do our regular commit setup, so that the query is re-evaluated\n      // (and potentially cause a refetch).\n      this._maybeHiddenOrFastRefresh = false; // eslint-disable-next-line react/no-did-mount-set-state\n\n      this.setState(function (prevState) {\n        return resetQueryStateForUpdate(_this2.props, prevState);\n      });\n      return;\n    }\n\n    var _this$state = this.state,\n        retryCallbacks = _this$state.retryCallbacks,\n        queryFetcher = _this$state.queryFetcher,\n        requestCacheKey = _this$state.requestCacheKey; // We don't need to cache the request after the component commits\n\n    if (requestCacheKey) {\n      delete requestCache[requestCacheKey];\n    }\n\n    retryCallbacks.handleDataChange = this._handleDataChange;\n\n    retryCallbacks.handleRetryAfterError = function (error) {\n      return _this2.setState(function (prevState) {\n        var prevRequestCacheKey = prevState.requestCacheKey;\n\n        if (prevRequestCacheKey) {\n          delete requestCache[prevRequestCacheKey];\n        }\n\n        return {\n          renderProps: getLoadingRenderProps(),\n          requestCacheKey: null\n        };\n      });\n    }; // Re-initialize the ReactRelayQueryFetcher with callbacks.\n    // If data has changed since constructions, this will re-render.\n\n\n    if (this.props.query) {\n      queryFetcher.setOnDataChange(this._handleDataChange);\n    }\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(_prevProps, prevState) {\n    // We don't need to cache the request after the component commits\n    var _this$state2 = this.state,\n        queryFetcher = _this$state2.queryFetcher,\n        requestCacheKey = _this$state2.requestCacheKey;\n\n    if (requestCacheKey) {\n      delete requestCache[requestCacheKey]; // HACK\n\n      delete this.state.requestCacheKey;\n    }\n\n    if (this.props.query && queryFetcher !== prevState.queryFetcher) {\n      queryFetcher.setOnDataChange(this._handleDataChange);\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.state.queryFetcher.dispose();\n    this._maybeHiddenOrFastRefresh = true;\n  };\n\n  _proto.shouldComponentUpdate = function shouldComponentUpdate(nextProps, nextState) {\n    return nextProps.render !== this.props.render || nextState.renderProps !== this.state.renderProps;\n  };\n\n  _proto.render = function render() {\n    var _this$state3 = this.state,\n        renderProps = _this$state3.renderProps,\n        relayContext = _this$state3.relayContext; // Note that the root fragment results in `renderProps.props` is already\n    // frozen by the store; this call is to freeze the renderProps object and\n    // error property if set.\n\n    if (process.env.NODE_ENV !== \"production\") {\n      deepFreeze(renderProps);\n    }\n\n    return /*#__PURE__*/React.createElement(ReactRelayContext.Provider, {\n      value: relayContext\n    }, /*#__PURE__*/React.createElement(ReactRelayQueryRendererContext.Provider, {\n      value: queryRendererContext\n    }, this.props.render(renderProps)));\n  };\n\n  return ReactRelayQueryRenderer;\n}(React.Component);\n\nfunction getLoadingRenderProps() {\n  return {\n    error: null,\n    props: null,\n    // `props: null` indicates that the data is being fetched (i.e. loading)\n    retry: null\n  };\n}\n\nfunction getEmptyRenderProps() {\n  return {\n    error: null,\n    props: {},\n    // `props: {}` indicates no data available\n    retry: null\n  };\n}\n\nfunction getRenderProps(error, snapshot, queryFetcher, retryCallbacks) {\n  return {\n    error: error ? error : null,\n    props: snapshot ? snapshot.data : null,\n    retry: function retry(cacheConfigOverride) {\n      var syncSnapshot = queryFetcher.retry(cacheConfigOverride);\n\n      if (syncSnapshot && typeof retryCallbacks.handleDataChange === 'function') {\n        retryCallbacks.handleDataChange({\n          snapshot: syncSnapshot\n        });\n      } else if (error && typeof retryCallbacks.handleRetryAfterError === 'function') {\n        // If retrying after an error and no synchronous result available,\n        // reset the render props\n        retryCallbacks.handleRetryAfterError(error);\n      }\n    }\n  };\n}\n\nfunction getRequestCacheKey(request, variables) {\n  return JSON.stringify({\n    id: request.cacheID ? request.cacheID : request.id,\n    variables: variables\n  });\n}\n\nfunction resetQueryStateForUpdate(props, prevState) {\n  var query = props.query;\n  var prevSelectionReferences = prevState.queryFetcher.getSelectionReferences();\n  prevState.queryFetcher.disposeRequest();\n  var queryFetcher;\n\n  if (query) {\n    var request = getRequest(query);\n    var requestCacheKey = getRequestCacheKey(request.params, props.variables);\n    queryFetcher = requestCache[requestCacheKey] ? requestCache[requestCacheKey].queryFetcher : new ReactRelayQueryFetcher(prevSelectionReferences);\n  } else {\n    queryFetcher = new ReactRelayQueryFetcher(prevSelectionReferences);\n  }\n\n  return (0, _objectSpread2[\"default\"])({\n    prevQuery: props.query,\n    prevPropsEnvironment: props.environment,\n    prevPropsVariables: props.variables,\n    queryFetcher: queryFetcher\n  }, fetchQueryAndComputeStateFromProps(props, queryFetcher, prevState.retryCallbacks // passing no requestCacheKey will cause it to be recalculated internally\n  // and we want the updated requestCacheKey, since variables may have changed\n  ));\n}\n\nfunction fetchQueryAndComputeStateFromProps(props, queryFetcher, retryCallbacks, requestCacheKey) {\n  var environment = props.environment,\n      query = props.query,\n      variables = props.variables,\n      cacheConfig = props.cacheConfig;\n  var genericEnvironment = environment;\n\n  if (query) {\n    var request = getRequest(query);\n    var operation = createOperationDescriptor(request, variables, cacheConfig);\n    var relayContext = {\n      environment: genericEnvironment\n    };\n\n    if (typeof requestCacheKey === 'string' && requestCache[requestCacheKey]) {\n      // This same request is already in flight.\n      var snapshot = requestCache[requestCacheKey].snapshot;\n\n      if (snapshot) {\n        // Use the cached response\n        return {\n          error: null,\n          relayContext: relayContext,\n          renderProps: getRenderProps(null, snapshot, queryFetcher, retryCallbacks),\n          snapshot: snapshot,\n          requestCacheKey: requestCacheKey\n        };\n      } else {\n        // Render loading state\n        return {\n          error: null,\n          relayContext: relayContext,\n          renderProps: getLoadingRenderProps(),\n          snapshot: null,\n          requestCacheKey: requestCacheKey\n        };\n      }\n    }\n\n    try {\n      var storeSnapshot = queryFetcher.lookupInStore(genericEnvironment, operation, props.fetchPolicy);\n      var querySnapshot = queryFetcher.fetch({\n        environment: genericEnvironment,\n        onDataChange: null,\n        operation: operation\n      }); // Use network data first, since it may be fresher\n\n      var _snapshot = querySnapshot || storeSnapshot; // cache the request to avoid duplicate requests\n\n\n      requestCacheKey = requestCacheKey || getRequestCacheKey(request.params, props.variables);\n      requestCache[requestCacheKey] = {\n        queryFetcher: queryFetcher,\n        snapshot: _snapshot\n      };\n\n      if (!_snapshot) {\n        return {\n          error: null,\n          relayContext: relayContext,\n          renderProps: getLoadingRenderProps(),\n          snapshot: null,\n          requestCacheKey: requestCacheKey\n        };\n      }\n\n      return {\n        error: null,\n        relayContext: relayContext,\n        renderProps: getRenderProps(null, _snapshot, queryFetcher, retryCallbacks),\n        snapshot: _snapshot,\n        requestCacheKey: requestCacheKey\n      };\n    } catch (error) {\n      return {\n        error: error,\n        relayContext: relayContext,\n        renderProps: getRenderProps(error, null, queryFetcher, retryCallbacks),\n        snapshot: null,\n        requestCacheKey: requestCacheKey\n      };\n    }\n  } else {\n    queryFetcher.dispose();\n    var _relayContext = {\n      environment: genericEnvironment\n    };\n    return {\n      error: null,\n      relayContext: _relayContext,\n      renderProps: getEmptyRenderProps(),\n      requestCacheKey: null // if there is an error, don't cache request\n\n    };\n  }\n}\n\nmodule.exports = ReactRelayQueryRenderer;"]},"metadata":{},"sourceType":"script"}