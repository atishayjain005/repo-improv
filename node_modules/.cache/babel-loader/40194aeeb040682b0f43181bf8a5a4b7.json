{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @emails oncall+relay\n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar LRUCache = require('./LRUCache');\n\nvar invariant = require('invariant');\n\nvar _require = require('relay-runtime'),\n    getFragmentIdentifier = _require.getFragmentIdentifier,\n    getPendingOperationsForFragment = _require.getPendingOperationsForFragment,\n    getSelector = _require.getSelector,\n    isPromise = _require.isPromise,\n    recycleNodesInto = _require.recycleNodesInto,\n    reportMissingRequiredFields = _require.reportMissingRequiredFields;\n\nvar WEAKMAP_SUPPORTED = typeof WeakMap === 'function'; // TODO: Fix to not rely on LRU. If the number of active fragments exceeds this\n// capacity, readSpec() will fail to find cached entries and break object\n// identity even if data hasn't changed.\n\nvar CACHE_CAPACITY = 1000000; // this is frozen so that users don't accidentally push data into the array\n\nvar CONSTANT_READONLY_EMPTY_ARRAY = Object.freeze([]);\n\nfunction isMissingData(snapshot) {\n  if (Array.isArray(snapshot)) {\n    return snapshot.some(function (s) {\n      return s.isMissingData;\n    });\n  }\n\n  return snapshot.isMissingData;\n}\n\nfunction getFragmentResult(cacheKey, snapshot, storeEpoch) {\n  if (Array.isArray(snapshot)) {\n    return {\n      cacheKey: cacheKey,\n      snapshot: snapshot,\n      data: snapshot.map(function (s) {\n        return s.data;\n      }),\n      isMissingData: isMissingData(snapshot),\n      storeEpoch: storeEpoch\n    };\n  }\n\n  return {\n    cacheKey: cacheKey,\n    snapshot: snapshot,\n    data: snapshot.data,\n    isMissingData: isMissingData(snapshot),\n    storeEpoch: storeEpoch\n  };\n}\n\nvar FragmentResourceImpl = /*#__PURE__*/function () {\n  function FragmentResourceImpl(environment) {\n    this._environment = environment;\n    this._cache = LRUCache.create(CACHE_CAPACITY);\n  }\n  /**\n   * This function should be called during a Component's render function,\n   * to read the data for a fragment, or suspend if the fragment is being\n   * fetched.\n   */\n\n\n  var _proto = FragmentResourceImpl.prototype;\n\n  _proto.read = function read(fragmentNode, fragmentRef, componentDisplayName, fragmentKey) {\n    return this.readWithIdentifier(fragmentNode, fragmentRef, getFragmentIdentifier(fragmentNode, fragmentRef), componentDisplayName, fragmentKey);\n  }\n  /**\n   * Like `read`, but with a pre-computed fragmentIdentifier that should be\n   * equal to `getFragmentIdentifier(fragmentNode, fragmentRef)` from the\n   * arguments.\n   */\n  ;\n\n  _proto.readWithIdentifier = function readWithIdentifier(fragmentNode, fragmentRef, fragmentIdentifier, componentDisplayName, fragmentKey) {\n    var _fragmentNode$metadat;\n\n    var environment = this._environment; // If fragmentRef is null or undefined, pass it directly through.\n    // This is a convenience when consuming fragments via a HOC API, when the\n    // prop corresponding to the fragment ref might be passed as null.\n\n    if (fragmentRef == null) {\n      return {\n        cacheKey: fragmentIdentifier,\n        data: null,\n        isMissingData: false,\n        snapshot: null,\n        storeEpoch: 0\n      };\n    }\n\n    var storeEpoch = environment.getStore().getEpoch(); // If fragmentRef is plural, ensure that it is an array.\n    // If it's empty, return the empty array directly before doing any more work.\n\n    if ((fragmentNode === null || fragmentNode === void 0 ? void 0 : (_fragmentNode$metadat = fragmentNode.metadata) === null || _fragmentNode$metadat === void 0 ? void 0 : _fragmentNode$metadat.plural) === true) {\n      !Array.isArray(fragmentRef) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected fragment pointer%s for fragment `%s` to be ' + 'an array, instead got `%s`. Remove `@relay(plural: true)` ' + 'from fragment `%s` to allow the prop to be an object.', fragmentKey != null ? \" for key `\".concat(fragmentKey, \"`\") : '', fragmentNode.name, typeof fragmentRef, fragmentNode.name) : invariant(false) : void 0;\n\n      if (fragmentRef.length === 0) {\n        return {\n          cacheKey: fragmentIdentifier,\n          data: CONSTANT_READONLY_EMPTY_ARRAY,\n          isMissingData: false,\n          snapshot: CONSTANT_READONLY_EMPTY_ARRAY,\n          storeEpoch: storeEpoch\n        };\n      }\n    } // Now we actually attempt to read the fragment:\n    // 1. Check if there's a cached value for this fragment\n\n\n    var cachedValue = this._cache.get(fragmentIdentifier);\n\n    if (cachedValue != null) {\n      if (cachedValue.kind === 'pending' && isPromise(cachedValue.promise)) {\n        environment.__log({\n          name: 'suspense.fragment',\n          data: cachedValue.result.data,\n          fragment: fragmentNode,\n          isRelayHooks: true,\n          isMissingData: cachedValue.result.isMissingData,\n          isPromiseCached: true,\n          pendingOperations: cachedValue.pendingOperations\n        });\n\n        throw cachedValue.promise;\n      }\n\n      if (cachedValue.kind === 'done' && cachedValue.result.snapshot) {\n        this._reportMissingRequiredFieldsInSnapshot(cachedValue.result.snapshot);\n\n        return cachedValue.result;\n      }\n    } // 2. If not, try reading the fragment from the Relay store.\n    // If the snapshot has data, return it and save it in cache\n\n\n    var fragmentSelector = getSelector(fragmentNode, fragmentRef);\n    !(fragmentSelector != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected to receive an object where `...%s` was spread, ' + 'but the fragment reference was not found`. This is most ' + 'likely the result of:\\n' + \"- Forgetting to spread `%s` in `%s`'s parent's fragment.\\n\" + '- Conditionally fetching `%s` but unconditionally passing %s prop ' + 'to `%s`. If the parent fragment only fetches the fragment conditionally ' + '- with e.g. `@include`, `@skip`, or inside a `... on SomeType { }` ' + 'spread  - then the fragment reference will not exist. ' + 'In this case, pass `null` if the conditions for evaluating the ' + 'fragment are not met (e.g. if the `@include(if)` value is false.)', fragmentNode.name, fragmentNode.name, componentDisplayName, fragmentNode.name, fragmentKey == null ? 'a fragment reference' : \"the `\".concat(fragmentKey, \"`\"), componentDisplayName) : invariant(false) : void 0;\n    var snapshot = fragmentSelector.kind === 'PluralReaderSelector' ? fragmentSelector.selectors.map(function (s) {\n      return environment.lookup(s);\n    }) : environment.lookup(fragmentSelector);\n    var fragmentResult = getFragmentResult(fragmentIdentifier, snapshot, storeEpoch);\n\n    if (!fragmentResult.isMissingData) {\n      this._reportMissingRequiredFieldsInSnapshot(snapshot);\n\n      this._cache.set(fragmentIdentifier, {\n        kind: 'done',\n        result: fragmentResult\n      });\n\n      return fragmentResult;\n    } // 3. If we don't have data in the store, check if a request is in\n    // flight for the fragment's parent query, or for another operation\n    // that may affect the parent's query data, such as a mutation\n    // or subscription. If a promise exists, cache the promise and use it\n    // to suspend.\n\n\n    var fragmentOwner = fragmentSelector.kind === 'PluralReaderSelector' ? fragmentSelector.selectors[0].owner : fragmentSelector.owner;\n\n    var networkPromiseResult = this._getAndSavePromiseForFragmentRequestInFlight(fragmentIdentifier, fragmentNode, fragmentOwner, fragmentResult);\n\n    if (networkPromiseResult != null && isPromise(networkPromiseResult.promise)) {\n      environment.__log({\n        name: 'suspense.fragment',\n        data: fragmentResult.data,\n        fragment: fragmentNode,\n        isRelayHooks: true,\n        isPromiseCached: false,\n        isMissingData: fragmentResult.isMissingData,\n        pendingOperations: networkPromiseResult.pendingOperations\n      });\n\n      throw networkPromiseResult.promise;\n    }\n\n    this._reportMissingRequiredFieldsInSnapshot(snapshot);\n\n    return getFragmentResult(fragmentIdentifier, snapshot, storeEpoch);\n  };\n\n  _proto._reportMissingRequiredFieldsInSnapshot = function _reportMissingRequiredFieldsInSnapshot(snapshot) {\n    var _this = this;\n\n    if (Array.isArray(snapshot)) {\n      snapshot.forEach(function (s) {\n        if (s.missingRequiredFields != null) {\n          reportMissingRequiredFields(_this._environment, s.missingRequiredFields);\n        }\n      });\n    } else {\n      if (snapshot.missingRequiredFields != null) {\n        reportMissingRequiredFields(this._environment, snapshot.missingRequiredFields);\n      }\n    }\n  };\n\n  _proto.readSpec = function readSpec(fragmentNodes, fragmentRefs, componentDisplayName) {\n    var result = {};\n\n    for (var _key in fragmentNodes) {\n      result[_key] = this.read(fragmentNodes[_key], fragmentRefs[_key], componentDisplayName, _key);\n    }\n\n    return result;\n  };\n\n  _proto.subscribe = function subscribe(fragmentResult, callback) {\n    var _this2 = this;\n\n    var environment = this._environment;\n    var cacheKey = fragmentResult.cacheKey;\n    var renderedSnapshot = fragmentResult.snapshot;\n\n    if (!renderedSnapshot) {\n      return {\n        dispose: function dispose() {}\n      };\n    } // 1. Check for any updates missed during render phase\n    // TODO(T44066760): More efficiently detect if we missed an update\n\n\n    var _this$checkMissedUpda = this.checkMissedUpdates(fragmentResult),\n        didMissUpdates = _this$checkMissedUpda[0],\n        currentSnapshot = _this$checkMissedUpda[1]; // 2. If an update was missed, notify the component so it updates with\n    // the latest data.\n\n\n    if (didMissUpdates) {\n      callback();\n    } // 3. Establish subscriptions on the snapshot(s)\n\n\n    var dataSubscriptions = [];\n\n    if (Array.isArray(renderedSnapshot)) {\n      !Array.isArray(currentSnapshot) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected snapshots to be plural. ' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0;\n      currentSnapshot.forEach(function (snapshot, idx) {\n        dataSubscriptions.push(environment.subscribe(snapshot, function (latestSnapshot) {\n          var storeEpoch = environment.getStore().getEpoch();\n\n          _this2._updatePluralSnapshot(cacheKey, currentSnapshot, latestSnapshot, idx, storeEpoch);\n\n          callback();\n        }));\n      });\n    } else {\n      !(currentSnapshot != null && !Array.isArray(currentSnapshot)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected snapshot to be singular. ' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0;\n      dataSubscriptions.push(environment.subscribe(currentSnapshot, function (latestSnapshot) {\n        var storeEpoch = environment.getStore().getEpoch();\n\n        _this2._cache.set(cacheKey, {\n          kind: 'done',\n          result: getFragmentResult(cacheKey, latestSnapshot, storeEpoch)\n        });\n\n        callback();\n      }));\n    }\n\n    return {\n      dispose: function dispose() {\n        dataSubscriptions.map(function (s) {\n          return s.dispose();\n        });\n\n        _this2._cache[\"delete\"](cacheKey);\n      }\n    };\n  };\n\n  _proto.subscribeSpec = function subscribeSpec(fragmentResults, callback) {\n    var _this3 = this;\n\n    var disposables = Object.keys(fragmentResults).map(function (key) {\n      return _this3.subscribe(fragmentResults[key], callback);\n    });\n    return {\n      dispose: function dispose() {\n        disposables.forEach(function (disposable) {\n          disposable.dispose();\n        });\n      }\n    };\n  };\n\n  _proto.checkMissedUpdates = function checkMissedUpdates(fragmentResult) {\n    var environment = this._environment;\n    var renderedSnapshot = fragmentResult.snapshot;\n\n    if (!renderedSnapshot) {\n      return [false, null];\n    }\n\n    var storeEpoch = null; // Bail out if the store hasn't been written since last read\n\n    storeEpoch = environment.getStore().getEpoch();\n\n    if (fragmentResult.storeEpoch === storeEpoch) {\n      return [false, fragmentResult.snapshot];\n    }\n\n    var cacheKey = fragmentResult.cacheKey;\n\n    if (Array.isArray(renderedSnapshot)) {\n      var didMissUpdates = false;\n      var currentSnapshots = [];\n      renderedSnapshot.forEach(function (snapshot, idx) {\n        var currentSnapshot = environment.lookup(snapshot.selector);\n        var renderData = snapshot.data;\n        var currentData = currentSnapshot.data;\n        var updatedData = recycleNodesInto(renderData, currentData);\n\n        if (updatedData !== renderData) {\n          currentSnapshot = (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, currentSnapshot), {}, {\n            data: updatedData\n          });\n          didMissUpdates = true;\n        }\n\n        currentSnapshots[idx] = currentSnapshot;\n      }); // Only update the cache when the data is changed to avoid\n      // returning different `data` instances\n\n      if (didMissUpdates) {\n        this._cache.set(cacheKey, {\n          kind: 'done',\n          result: getFragmentResult(cacheKey, currentSnapshots, storeEpoch)\n        });\n      }\n\n      return [didMissUpdates, currentSnapshots];\n    }\n\n    var currentSnapshot = environment.lookup(renderedSnapshot.selector);\n    var renderData = renderedSnapshot.data;\n    var currentData = currentSnapshot.data;\n    var updatedData = recycleNodesInto(renderData, currentData);\n    var updatedCurrentSnapshot = {\n      data: updatedData,\n      isMissingData: currentSnapshot.isMissingData,\n      seenRecords: currentSnapshot.seenRecords,\n      selector: currentSnapshot.selector,\n      missingRequiredFields: currentSnapshot.missingRequiredFields\n    };\n\n    if (updatedData !== renderData) {\n      this._cache.set(cacheKey, {\n        kind: 'done',\n        result: getFragmentResult(cacheKey, updatedCurrentSnapshot, storeEpoch)\n      });\n    }\n\n    return [updatedData !== renderData, updatedCurrentSnapshot];\n  };\n\n  _proto.checkMissedUpdatesSpec = function checkMissedUpdatesSpec(fragmentResults) {\n    var _this4 = this;\n\n    return Object.keys(fragmentResults).some(function (key) {\n      return _this4.checkMissedUpdates(fragmentResults[key])[0];\n    });\n  };\n\n  _proto._getAndSavePromiseForFragmentRequestInFlight = function _getAndSavePromiseForFragmentRequestInFlight(cacheKey, fragmentNode, fragmentOwner, fragmentResult) {\n    var _this5 = this;\n\n    var pendingOperationsResult = getPendingOperationsForFragment(this._environment, fragmentNode, fragmentOwner);\n\n    if (pendingOperationsResult == null) {\n      return null;\n    } // When the Promise for the request resolves, we need to make sure to\n    // update the cache with the latest data available in the store before\n    // resolving the Promise\n\n\n    var networkPromise = pendingOperationsResult.promise;\n    var pendingOperations = pendingOperationsResult.pendingOperations;\n    var promise = networkPromise.then(function () {\n      _this5._cache[\"delete\"](cacheKey);\n    })[\"catch\"](function (error) {\n      _this5._cache[\"delete\"](cacheKey);\n    }); // $FlowExpectedError[prop-missing] Expando to annotate Promises.\n\n    promise.displayName = networkPromise.displayName;\n\n    this._cache.set(cacheKey, {\n      kind: 'pending',\n      pendingOperations: pendingOperations,\n      promise: promise,\n      result: fragmentResult\n    });\n\n    return {\n      promise: promise,\n      pendingOperations: pendingOperations\n    };\n  };\n\n  _proto._updatePluralSnapshot = function _updatePluralSnapshot(cacheKey, baseSnapshots, latestSnapshot, idx, storeEpoch) {\n    var _currentFragmentResul;\n\n    var currentFragmentResult = this._cache.get(cacheKey);\n\n    if (isPromise(currentFragmentResult)) {\n      reportInvalidCachedData(latestSnapshot.selector.node.name);\n      return;\n    }\n\n    var currentSnapshot = currentFragmentResult === null || currentFragmentResult === void 0 ? void 0 : (_currentFragmentResul = currentFragmentResult.result) === null || _currentFragmentResul === void 0 ? void 0 : _currentFragmentResul.snapshot;\n\n    if (currentSnapshot && !Array.isArray(currentSnapshot)) {\n      reportInvalidCachedData(latestSnapshot.selector.node.name);\n      return;\n    }\n\n    var nextSnapshots = currentSnapshot ? (0, _toConsumableArray2[\"default\"])(currentSnapshot) : (0, _toConsumableArray2[\"default\"])(baseSnapshots);\n    nextSnapshots[idx] = latestSnapshot;\n\n    this._cache.set(cacheKey, {\n      kind: 'done',\n      result: getFragmentResult(cacheKey, nextSnapshots, storeEpoch)\n    });\n  };\n\n  return FragmentResourceImpl;\n}();\n\nfunction reportInvalidCachedData(nodeName) {\n  !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected to find cached data for plural fragment `%s` when ' + 'receiving a subscription. ' + \"If you're seeing this, this is likely a bug in Relay.\", nodeName) : invariant(false) : void 0;\n}\n\nfunction createFragmentResource(environment) {\n  return new FragmentResourceImpl(environment);\n}\n\nvar dataResources = WEAKMAP_SUPPORTED ? new WeakMap() : new Map();\n\nfunction getFragmentResourceForEnvironment(environment) {\n  var cached = dataResources.get(environment);\n\n  if (cached) {\n    return cached;\n  }\n\n  var newDataResource = createFragmentResource(environment);\n  dataResources.set(environment, newDataResource);\n  return newDataResource;\n}\n\nmodule.exports = {\n  createFragmentResource: createFragmentResource,\n  getFragmentResourceForEnvironment: getFragmentResourceForEnvironment\n};","map":{"version":3,"sources":["/home/akshay/Atishay/appointy-screening/node_modules/react-relay/lib/relay-hooks/FragmentResource.js"],"names":["_interopRequireDefault","require","_objectSpread2","_toConsumableArray2","LRUCache","invariant","_require","getFragmentIdentifier","getPendingOperationsForFragment","getSelector","isPromise","recycleNodesInto","reportMissingRequiredFields","WEAKMAP_SUPPORTED","WeakMap","CACHE_CAPACITY","CONSTANT_READONLY_EMPTY_ARRAY","Object","freeze","isMissingData","snapshot","Array","isArray","some","s","getFragmentResult","cacheKey","storeEpoch","data","map","FragmentResourceImpl","environment","_environment","_cache","create","_proto","prototype","read","fragmentNode","fragmentRef","componentDisplayName","fragmentKey","readWithIdentifier","fragmentIdentifier","_fragmentNode$metadat","getStore","getEpoch","metadata","plural","process","env","NODE_ENV","concat","name","length","cachedValue","get","kind","promise","__log","result","fragment","isRelayHooks","isPromiseCached","pendingOperations","_reportMissingRequiredFieldsInSnapshot","fragmentSelector","selectors","lookup","fragmentResult","set","fragmentOwner","owner","networkPromiseResult","_getAndSavePromiseForFragmentRequestInFlight","_this","forEach","missingRequiredFields","readSpec","fragmentNodes","fragmentRefs","_key","subscribe","callback","_this2","renderedSnapshot","dispose","_this$checkMissedUpda","checkMissedUpdates","didMissUpdates","currentSnapshot","dataSubscriptions","idx","push","latestSnapshot","_updatePluralSnapshot","subscribeSpec","fragmentResults","_this3","disposables","keys","key","disposable","currentSnapshots","selector","renderData","currentData","updatedData","updatedCurrentSnapshot","seenRecords","checkMissedUpdatesSpec","_this4","_this5","pendingOperationsResult","networkPromise","then","error","displayName","baseSnapshots","_currentFragmentResul","currentFragmentResult","reportInvalidCachedData","node","nextSnapshots","nodeName","createFragmentResource","dataResources","Map","getFragmentResourceForEnvironment","cached","newDataResource","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @emails oncall+relay\n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar LRUCache = require('./LRUCache');\n\nvar invariant = require('invariant');\n\nvar _require = require('relay-runtime'),\n    getFragmentIdentifier = _require.getFragmentIdentifier,\n    getPendingOperationsForFragment = _require.getPendingOperationsForFragment,\n    getSelector = _require.getSelector,\n    isPromise = _require.isPromise,\n    recycleNodesInto = _require.recycleNodesInto,\n    reportMissingRequiredFields = _require.reportMissingRequiredFields;\n\nvar WEAKMAP_SUPPORTED = typeof WeakMap === 'function';\n// TODO: Fix to not rely on LRU. If the number of active fragments exceeds this\n// capacity, readSpec() will fail to find cached entries and break object\n// identity even if data hasn't changed.\nvar CACHE_CAPACITY = 1000000; // this is frozen so that users don't accidentally push data into the array\n\nvar CONSTANT_READONLY_EMPTY_ARRAY = Object.freeze([]);\n\nfunction isMissingData(snapshot) {\n  if (Array.isArray(snapshot)) {\n    return snapshot.some(function (s) {\n      return s.isMissingData;\n    });\n  }\n\n  return snapshot.isMissingData;\n}\n\nfunction getFragmentResult(cacheKey, snapshot, storeEpoch) {\n  if (Array.isArray(snapshot)) {\n    return {\n      cacheKey: cacheKey,\n      snapshot: snapshot,\n      data: snapshot.map(function (s) {\n        return s.data;\n      }),\n      isMissingData: isMissingData(snapshot),\n      storeEpoch: storeEpoch\n    };\n  }\n\n  return {\n    cacheKey: cacheKey,\n    snapshot: snapshot,\n    data: snapshot.data,\n    isMissingData: isMissingData(snapshot),\n    storeEpoch: storeEpoch\n  };\n}\n\nvar FragmentResourceImpl = /*#__PURE__*/function () {\n  function FragmentResourceImpl(environment) {\n    this._environment = environment;\n    this._cache = LRUCache.create(CACHE_CAPACITY);\n  }\n  /**\n   * This function should be called during a Component's render function,\n   * to read the data for a fragment, or suspend if the fragment is being\n   * fetched.\n   */\n\n\n  var _proto = FragmentResourceImpl.prototype;\n\n  _proto.read = function read(fragmentNode, fragmentRef, componentDisplayName, fragmentKey) {\n    return this.readWithIdentifier(fragmentNode, fragmentRef, getFragmentIdentifier(fragmentNode, fragmentRef), componentDisplayName, fragmentKey);\n  }\n  /**\n   * Like `read`, but with a pre-computed fragmentIdentifier that should be\n   * equal to `getFragmentIdentifier(fragmentNode, fragmentRef)` from the\n   * arguments.\n   */\n  ;\n\n  _proto.readWithIdentifier = function readWithIdentifier(fragmentNode, fragmentRef, fragmentIdentifier, componentDisplayName, fragmentKey) {\n    var _fragmentNode$metadat;\n\n    var environment = this._environment; // If fragmentRef is null or undefined, pass it directly through.\n    // This is a convenience when consuming fragments via a HOC API, when the\n    // prop corresponding to the fragment ref might be passed as null.\n\n    if (fragmentRef == null) {\n      return {\n        cacheKey: fragmentIdentifier,\n        data: null,\n        isMissingData: false,\n        snapshot: null,\n        storeEpoch: 0\n      };\n    }\n\n    var storeEpoch = environment.getStore().getEpoch(); // If fragmentRef is plural, ensure that it is an array.\n    // If it's empty, return the empty array directly before doing any more work.\n\n    if ((fragmentNode === null || fragmentNode === void 0 ? void 0 : (_fragmentNode$metadat = fragmentNode.metadata) === null || _fragmentNode$metadat === void 0 ? void 0 : _fragmentNode$metadat.plural) === true) {\n      !Array.isArray(fragmentRef) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected fragment pointer%s for fragment `%s` to be ' + 'an array, instead got `%s`. Remove `@relay(plural: true)` ' + 'from fragment `%s` to allow the prop to be an object.', fragmentKey != null ? \" for key `\".concat(fragmentKey, \"`\") : '', fragmentNode.name, typeof fragmentRef, fragmentNode.name) : invariant(false) : void 0;\n\n      if (fragmentRef.length === 0) {\n        return {\n          cacheKey: fragmentIdentifier,\n          data: CONSTANT_READONLY_EMPTY_ARRAY,\n          isMissingData: false,\n          snapshot: CONSTANT_READONLY_EMPTY_ARRAY,\n          storeEpoch: storeEpoch\n        };\n      }\n    } // Now we actually attempt to read the fragment:\n    // 1. Check if there's a cached value for this fragment\n\n\n    var cachedValue = this._cache.get(fragmentIdentifier);\n\n    if (cachedValue != null) {\n      if (cachedValue.kind === 'pending' && isPromise(cachedValue.promise)) {\n        environment.__log({\n          name: 'suspense.fragment',\n          data: cachedValue.result.data,\n          fragment: fragmentNode,\n          isRelayHooks: true,\n          isMissingData: cachedValue.result.isMissingData,\n          isPromiseCached: true,\n          pendingOperations: cachedValue.pendingOperations\n        });\n\n        throw cachedValue.promise;\n      }\n\n      if (cachedValue.kind === 'done' && cachedValue.result.snapshot) {\n        this._reportMissingRequiredFieldsInSnapshot(cachedValue.result.snapshot);\n\n        return cachedValue.result;\n      }\n    } // 2. If not, try reading the fragment from the Relay store.\n    // If the snapshot has data, return it and save it in cache\n\n\n    var fragmentSelector = getSelector(fragmentNode, fragmentRef);\n    !(fragmentSelector != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected to receive an object where `...%s` was spread, ' + 'but the fragment reference was not found`. This is most ' + 'likely the result of:\\n' + \"- Forgetting to spread `%s` in `%s`'s parent's fragment.\\n\" + '- Conditionally fetching `%s` but unconditionally passing %s prop ' + 'to `%s`. If the parent fragment only fetches the fragment conditionally ' + '- with e.g. `@include`, `@skip`, or inside a `... on SomeType { }` ' + 'spread  - then the fragment reference will not exist. ' + 'In this case, pass `null` if the conditions for evaluating the ' + 'fragment are not met (e.g. if the `@include(if)` value is false.)', fragmentNode.name, fragmentNode.name, componentDisplayName, fragmentNode.name, fragmentKey == null ? 'a fragment reference' : \"the `\".concat(fragmentKey, \"`\"), componentDisplayName) : invariant(false) : void 0;\n    var snapshot = fragmentSelector.kind === 'PluralReaderSelector' ? fragmentSelector.selectors.map(function (s) {\n      return environment.lookup(s);\n    }) : environment.lookup(fragmentSelector);\n    var fragmentResult = getFragmentResult(fragmentIdentifier, snapshot, storeEpoch);\n\n    if (!fragmentResult.isMissingData) {\n      this._reportMissingRequiredFieldsInSnapshot(snapshot);\n\n      this._cache.set(fragmentIdentifier, {\n        kind: 'done',\n        result: fragmentResult\n      });\n\n      return fragmentResult;\n    } // 3. If we don't have data in the store, check if a request is in\n    // flight for the fragment's parent query, or for another operation\n    // that may affect the parent's query data, such as a mutation\n    // or subscription. If a promise exists, cache the promise and use it\n    // to suspend.\n\n\n    var fragmentOwner = fragmentSelector.kind === 'PluralReaderSelector' ? fragmentSelector.selectors[0].owner : fragmentSelector.owner;\n\n    var networkPromiseResult = this._getAndSavePromiseForFragmentRequestInFlight(fragmentIdentifier, fragmentNode, fragmentOwner, fragmentResult);\n\n    if (networkPromiseResult != null && isPromise(networkPromiseResult.promise)) {\n      environment.__log({\n        name: 'suspense.fragment',\n        data: fragmentResult.data,\n        fragment: fragmentNode,\n        isRelayHooks: true,\n        isPromiseCached: false,\n        isMissingData: fragmentResult.isMissingData,\n        pendingOperations: networkPromiseResult.pendingOperations\n      });\n\n      throw networkPromiseResult.promise;\n    }\n\n    this._reportMissingRequiredFieldsInSnapshot(snapshot);\n\n    return getFragmentResult(fragmentIdentifier, snapshot, storeEpoch);\n  };\n\n  _proto._reportMissingRequiredFieldsInSnapshot = function _reportMissingRequiredFieldsInSnapshot(snapshot) {\n    var _this = this;\n\n    if (Array.isArray(snapshot)) {\n      snapshot.forEach(function (s) {\n        if (s.missingRequiredFields != null) {\n          reportMissingRequiredFields(_this._environment, s.missingRequiredFields);\n        }\n      });\n    } else {\n      if (snapshot.missingRequiredFields != null) {\n        reportMissingRequiredFields(this._environment, snapshot.missingRequiredFields);\n      }\n    }\n  };\n\n  _proto.readSpec = function readSpec(fragmentNodes, fragmentRefs, componentDisplayName) {\n    var result = {};\n\n    for (var _key in fragmentNodes) {\n      result[_key] = this.read(fragmentNodes[_key], fragmentRefs[_key], componentDisplayName, _key);\n    }\n\n    return result;\n  };\n\n  _proto.subscribe = function subscribe(fragmentResult, callback) {\n    var _this2 = this;\n\n    var environment = this._environment;\n    var cacheKey = fragmentResult.cacheKey;\n    var renderedSnapshot = fragmentResult.snapshot;\n\n    if (!renderedSnapshot) {\n      return {\n        dispose: function dispose() {}\n      };\n    } // 1. Check for any updates missed during render phase\n    // TODO(T44066760): More efficiently detect if we missed an update\n\n\n    var _this$checkMissedUpda = this.checkMissedUpdates(fragmentResult),\n        didMissUpdates = _this$checkMissedUpda[0],\n        currentSnapshot = _this$checkMissedUpda[1]; // 2. If an update was missed, notify the component so it updates with\n    // the latest data.\n\n\n    if (didMissUpdates) {\n      callback();\n    } // 3. Establish subscriptions on the snapshot(s)\n\n\n    var dataSubscriptions = [];\n\n    if (Array.isArray(renderedSnapshot)) {\n      !Array.isArray(currentSnapshot) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected snapshots to be plural. ' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0;\n      currentSnapshot.forEach(function (snapshot, idx) {\n        dataSubscriptions.push(environment.subscribe(snapshot, function (latestSnapshot) {\n          var storeEpoch = environment.getStore().getEpoch();\n\n          _this2._updatePluralSnapshot(cacheKey, currentSnapshot, latestSnapshot, idx, storeEpoch);\n\n          callback();\n        }));\n      });\n    } else {\n      !(currentSnapshot != null && !Array.isArray(currentSnapshot)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected snapshot to be singular. ' + \"If you're seeing this, this is likely a bug in Relay.\") : invariant(false) : void 0;\n      dataSubscriptions.push(environment.subscribe(currentSnapshot, function (latestSnapshot) {\n        var storeEpoch = environment.getStore().getEpoch();\n\n        _this2._cache.set(cacheKey, {\n          kind: 'done',\n          result: getFragmentResult(cacheKey, latestSnapshot, storeEpoch)\n        });\n\n        callback();\n      }));\n    }\n\n    return {\n      dispose: function dispose() {\n        dataSubscriptions.map(function (s) {\n          return s.dispose();\n        });\n\n        _this2._cache[\"delete\"](cacheKey);\n      }\n    };\n  };\n\n  _proto.subscribeSpec = function subscribeSpec(fragmentResults, callback) {\n    var _this3 = this;\n\n    var disposables = Object.keys(fragmentResults).map(function (key) {\n      return _this3.subscribe(fragmentResults[key], callback);\n    });\n    return {\n      dispose: function dispose() {\n        disposables.forEach(function (disposable) {\n          disposable.dispose();\n        });\n      }\n    };\n  };\n\n  _proto.checkMissedUpdates = function checkMissedUpdates(fragmentResult) {\n    var environment = this._environment;\n    var renderedSnapshot = fragmentResult.snapshot;\n\n    if (!renderedSnapshot) {\n      return [false, null];\n    }\n\n    var storeEpoch = null; // Bail out if the store hasn't been written since last read\n\n    storeEpoch = environment.getStore().getEpoch();\n\n    if (fragmentResult.storeEpoch === storeEpoch) {\n      return [false, fragmentResult.snapshot];\n    }\n\n    var cacheKey = fragmentResult.cacheKey;\n\n    if (Array.isArray(renderedSnapshot)) {\n      var didMissUpdates = false;\n      var currentSnapshots = [];\n      renderedSnapshot.forEach(function (snapshot, idx) {\n        var currentSnapshot = environment.lookup(snapshot.selector);\n        var renderData = snapshot.data;\n        var currentData = currentSnapshot.data;\n        var updatedData = recycleNodesInto(renderData, currentData);\n\n        if (updatedData !== renderData) {\n          currentSnapshot = (0, _objectSpread2[\"default\"])((0, _objectSpread2[\"default\"])({}, currentSnapshot), {}, {\n            data: updatedData\n          });\n          didMissUpdates = true;\n        }\n\n        currentSnapshots[idx] = currentSnapshot;\n      }); // Only update the cache when the data is changed to avoid\n      // returning different `data` instances\n\n      if (didMissUpdates) {\n        this._cache.set(cacheKey, {\n          kind: 'done',\n          result: getFragmentResult(cacheKey, currentSnapshots, storeEpoch)\n        });\n      }\n\n      return [didMissUpdates, currentSnapshots];\n    }\n\n    var currentSnapshot = environment.lookup(renderedSnapshot.selector);\n    var renderData = renderedSnapshot.data;\n    var currentData = currentSnapshot.data;\n    var updatedData = recycleNodesInto(renderData, currentData);\n    var updatedCurrentSnapshot = {\n      data: updatedData,\n      isMissingData: currentSnapshot.isMissingData,\n      seenRecords: currentSnapshot.seenRecords,\n      selector: currentSnapshot.selector,\n      missingRequiredFields: currentSnapshot.missingRequiredFields\n    };\n\n    if (updatedData !== renderData) {\n      this._cache.set(cacheKey, {\n        kind: 'done',\n        result: getFragmentResult(cacheKey, updatedCurrentSnapshot, storeEpoch)\n      });\n    }\n\n    return [updatedData !== renderData, updatedCurrentSnapshot];\n  };\n\n  _proto.checkMissedUpdatesSpec = function checkMissedUpdatesSpec(fragmentResults) {\n    var _this4 = this;\n\n    return Object.keys(fragmentResults).some(function (key) {\n      return _this4.checkMissedUpdates(fragmentResults[key])[0];\n    });\n  };\n\n  _proto._getAndSavePromiseForFragmentRequestInFlight = function _getAndSavePromiseForFragmentRequestInFlight(cacheKey, fragmentNode, fragmentOwner, fragmentResult) {\n    var _this5 = this;\n\n    var pendingOperationsResult = getPendingOperationsForFragment(this._environment, fragmentNode, fragmentOwner);\n\n    if (pendingOperationsResult == null) {\n      return null;\n    } // When the Promise for the request resolves, we need to make sure to\n    // update the cache with the latest data available in the store before\n    // resolving the Promise\n\n\n    var networkPromise = pendingOperationsResult.promise;\n    var pendingOperations = pendingOperationsResult.pendingOperations;\n    var promise = networkPromise.then(function () {\n      _this5._cache[\"delete\"](cacheKey);\n    })[\"catch\"](function (error) {\n      _this5._cache[\"delete\"](cacheKey);\n    }); // $FlowExpectedError[prop-missing] Expando to annotate Promises.\n\n    promise.displayName = networkPromise.displayName;\n\n    this._cache.set(cacheKey, {\n      kind: 'pending',\n      pendingOperations: pendingOperations,\n      promise: promise,\n      result: fragmentResult\n    });\n\n    return {\n      promise: promise,\n      pendingOperations: pendingOperations\n    };\n  };\n\n  _proto._updatePluralSnapshot = function _updatePluralSnapshot(cacheKey, baseSnapshots, latestSnapshot, idx, storeEpoch) {\n    var _currentFragmentResul;\n\n    var currentFragmentResult = this._cache.get(cacheKey);\n\n    if (isPromise(currentFragmentResult)) {\n      reportInvalidCachedData(latestSnapshot.selector.node.name);\n      return;\n    }\n\n    var currentSnapshot = currentFragmentResult === null || currentFragmentResult === void 0 ? void 0 : (_currentFragmentResul = currentFragmentResult.result) === null || _currentFragmentResul === void 0 ? void 0 : _currentFragmentResul.snapshot;\n\n    if (currentSnapshot && !Array.isArray(currentSnapshot)) {\n      reportInvalidCachedData(latestSnapshot.selector.node.name);\n      return;\n    }\n\n    var nextSnapshots = currentSnapshot ? (0, _toConsumableArray2[\"default\"])(currentSnapshot) : (0, _toConsumableArray2[\"default\"])(baseSnapshots);\n    nextSnapshots[idx] = latestSnapshot;\n\n    this._cache.set(cacheKey, {\n      kind: 'done',\n      result: getFragmentResult(cacheKey, nextSnapshots, storeEpoch)\n    });\n  };\n\n  return FragmentResourceImpl;\n}();\n\nfunction reportInvalidCachedData(nodeName) {\n  !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Relay: Expected to find cached data for plural fragment `%s` when ' + 'receiving a subscription. ' + \"If you're seeing this, this is likely a bug in Relay.\", nodeName) : invariant(false) : void 0;\n}\n\nfunction createFragmentResource(environment) {\n  return new FragmentResourceImpl(environment);\n}\n\nvar dataResources = WEAKMAP_SUPPORTED ? new WeakMap() : new Map();\n\nfunction getFragmentResourceForEnvironment(environment) {\n  var cached = dataResources.get(environment);\n\n  if (cached) {\n    return cached;\n  }\n\n  var newDataResource = createFragmentResource(environment);\n  dataResources.set(environment, newDataResource);\n  return newDataResource;\n}\n\nmodule.exports = {\n  createFragmentResource: createFragmentResource,\n  getFragmentResourceForEnvironment: getFragmentResourceForEnvironment\n};"]},"metadata":{},"sourceType":"script"}