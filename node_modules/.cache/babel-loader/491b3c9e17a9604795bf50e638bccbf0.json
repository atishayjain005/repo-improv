{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar areEqual = require(\"fbjs/lib/areEqual\");\n\nvar deepFreeze = require('../util/deepFreeze');\n\nvar invariant = require('invariant');\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar _require = require('./ClientID'),\n    isClientID = _require.isClientID;\n\nvar _require2 = require('./RelayStoreUtils'),\n    ACTOR_IDENTIFIER_KEY = _require2.ACTOR_IDENTIFIER_KEY,\n    ID_KEY = _require2.ID_KEY,\n    REF_KEY = _require2.REF_KEY,\n    REFS_KEY = _require2.REFS_KEY,\n    TYPENAME_KEY = _require2.TYPENAME_KEY,\n    INVALIDATED_AT_KEY = _require2.INVALIDATED_AT_KEY,\n    ROOT_ID = _require2.ROOT_ID;\n/**\n * @public\n *\n * Low-level record manipulation methods.\n *\n * A note about perf: we use long-hand property access rather than computed\n * properties in this file for speed ie.\n *\n *    const object = {};\n *    object[KEY] = value;\n *    record[storageKey] = object;\n *\n * instead of:\n *\n *    record[storageKey] = {\n *      [KEY]: value,\n *    };\n *\n * The latter gets transformed by Babel into something like:\n *\n *    function _defineProperty(obj, key, value) {\n *      if (key in obj) {\n *        Object.defineProperty(obj, key, {\n *          value: value,\n *          enumerable: true,\n *          configurable: true,\n *          writable: true,\n *        });\n *      } else {\n *        obj[key] = value;\n *      }\n *      return obj;\n *    }\n *\n *    record[storageKey] = _defineProperty({}, KEY, value);\n *\n * A quick benchmark shows that computed property access is an order of\n * magnitude slower (times in seconds for 100,000 iterations):\n *\n *               best     avg     sd\n *    computed 0.02175 0.02292 0.00113\n *      manual 0.00110 0.00123 0.00008\n */\n\n/**\n * @public\n *\n * Clone a record.\n */\n\n\nfunction clone(record) {\n  return (0, _objectSpread2[\"default\"])({}, record);\n}\n/**\n * @public\n *\n * Copies all fields from `source` to `sink`, excluding `__id` and `__typename`.\n *\n * NOTE: This function does not treat `id` specially. To preserve the id,\n * manually reset it after calling this function. Also note that values are\n * copied by reference and not value; callers should ensure that values are\n * copied on write.\n */\n\n\nfunction copyFields(source, sink) {\n  for (var key in source) {\n    if (source.hasOwnProperty(key)) {\n      if (key !== ID_KEY && key !== TYPENAME_KEY) {\n        sink[key] = source[key];\n      }\n    }\n  }\n}\n/**\n * @public\n *\n * Create a new record.\n */\n\n\nfunction create(dataID, typeName) {\n  // See perf note above for why we aren't using computed property access.\n  var record = {};\n  record[ID_KEY] = dataID;\n  record[TYPENAME_KEY] = typeName;\n  return record;\n}\n/**\n * @public\n *\n * Get the record's `id` if available or the client-generated identifier.\n */\n\n\nfunction getDataID(record) {\n  return record[ID_KEY];\n}\n/**\n * @public\n *\n * Get the concrete type of the record.\n */\n\n\nfunction getType(record) {\n  return record[TYPENAME_KEY];\n}\n/**\n * @public\n *\n * Get a scalar (non-link) field value.\n */\n\n\nfunction getValue(record, storageKey) {\n  var value = record[storageKey];\n\n  if (value && typeof value === 'object') {\n    !(!value.hasOwnProperty(REF_KEY) && !value.hasOwnProperty(REFS_KEY)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernRecord.getValue(): Expected a scalar (non-link) value for `%s.%s` ' + 'but found %s.', record[ID_KEY], storageKey, value.hasOwnProperty(REF_KEY) ? 'a linked record' : 'plural linked records') : invariant(false) : void 0;\n  }\n\n  return value;\n}\n/**\n * @public\n *\n * Get the value of a field as a reference to another record. Throws if the\n * field has a different type.\n */\n\n\nfunction getLinkedRecordID(record, storageKey) {\n  var link = record[storageKey];\n\n  if (link == null) {\n    return link;\n  }\n\n  !(typeof link === 'object' && link && typeof link[REF_KEY] === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernRecord.getLinkedRecordID(): Expected `%s.%s` to be a linked ID, ' + 'was `%s`.', record[ID_KEY], storageKey, JSON.stringify(link)) : invariant(false) : void 0;\n  return link[REF_KEY];\n}\n/**\n * @public\n *\n * Get the value of a field as a list of references to other records. Throws if\n * the field has a different type.\n */\n\n\nfunction getLinkedRecordIDs(record, storageKey) {\n  var links = record[storageKey];\n\n  if (links == null) {\n    return links;\n  }\n\n  !(typeof links === 'object' && Array.isArray(links[REFS_KEY])) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernRecord.getLinkedRecordIDs(): Expected `%s.%s` to contain an array ' + 'of linked IDs, got `%s`.', record[ID_KEY], storageKey, JSON.stringify(links)) : invariant(false) : void 0; // assume items of the array are ids\n\n  return links[REFS_KEY];\n}\n/**\n * @public\n *\n * Returns the epoch at which the record was invalidated, if it\n * ever was; otherwise returns null;\n */\n\n\nfunction getInvalidationEpoch(record) {\n  if (record == null) {\n    return null;\n  }\n\n  var invalidatedAt = record[INVALIDATED_AT_KEY];\n\n  if (typeof invalidatedAt !== 'number') {\n    // If the record has never been invalidated, it isn't stale.\n    return null;\n  }\n\n  return invalidatedAt;\n}\n/**\n * @public\n *\n * Compares the fields of a previous and new record, returning either the\n * previous record if all fields are equal or a new record (with merged fields)\n * if any fields have changed.\n */\n\n\nfunction update(prevRecord, nextRecord) {\n  if (process.env.NODE_ENV !== \"production\") {\n    var _getType, _getType2;\n\n    var prevID = getDataID(prevRecord);\n    var nextID = getDataID(nextRecord);\n    process.env.NODE_ENV !== \"production\" ? warning(prevID === nextID, 'RelayModernRecord: Invalid record update, expected both versions of ' + 'the record to have the same id, got `%s` and `%s`.', prevID, nextID) : void 0; // note: coalesce null/undefined to null\n\n    var prevType = (_getType = getType(prevRecord)) !== null && _getType !== void 0 ? _getType : null;\n    var nextType = (_getType2 = getType(nextRecord)) !== null && _getType2 !== void 0 ? _getType2 : null;\n    process.env.NODE_ENV !== \"production\" ? warning(isClientID(nextID) && nextID !== ROOT_ID || prevType === nextType, 'RelayModernRecord: Invalid record update, expected both versions of ' + 'record `%s` to have the same `%s` but got conflicting types `%s` ' + 'and `%s`. The GraphQL server likely violated the globally unique ' + 'id requirement by returning the same id for different objects.', prevID, TYPENAME_KEY, prevType, nextType) : void 0;\n  }\n\n  var updated = null;\n  var keys = Object.keys(nextRecord);\n\n  for (var ii = 0; ii < keys.length; ii++) {\n    var key = keys[ii];\n\n    if (updated || !areEqual(prevRecord[key], nextRecord[key])) {\n      updated = updated !== null ? updated : (0, _objectSpread2[\"default\"])({}, prevRecord);\n      updated[key] = nextRecord[key];\n    }\n  }\n\n  return updated !== null ? updated : prevRecord;\n}\n/**\n * @public\n *\n * Returns a new record with the contents of the given records. Fields in the\n * second record will overwrite identical fields in the first record.\n */\n\n\nfunction merge(record1, record2) {\n  if (process.env.NODE_ENV !== \"production\") {\n    var _getType3, _getType4;\n\n    var prevID = getDataID(record1);\n    var nextID = getDataID(record2);\n    process.env.NODE_ENV !== \"production\" ? warning(prevID === nextID, 'RelayModernRecord: Invalid record merge, expected both versions of ' + 'the record to have the same id, got `%s` and `%s`.', prevID, nextID) : void 0; // note: coalesce null/undefined to null\n\n    var prevType = (_getType3 = getType(record1)) !== null && _getType3 !== void 0 ? _getType3 : null;\n    var nextType = (_getType4 = getType(record2)) !== null && _getType4 !== void 0 ? _getType4 : null;\n    process.env.NODE_ENV !== \"production\" ? warning(isClientID(nextID) && nextID !== ROOT_ID || prevType === nextType, 'RelayModernRecord: Invalid record merge, expected both versions of ' + 'record `%s` to have the same `%s` but got conflicting types `%s` ' + 'and `%s`. The GraphQL server likely violated the globally unique ' + 'id requirement by returning the same id for different objects.', prevID, TYPENAME_KEY, prevType, nextType) : void 0;\n  }\n\n  return Object.assign({}, record1, record2);\n}\n/**\n * @public\n *\n * Prevent modifications to the record. Attempts to call `set*` functions on a\n * frozen record will fatal at runtime.\n */\n\n\nfunction freeze(record) {\n  deepFreeze(record);\n}\n/**\n * @public\n *\n * Set the value of a storageKey to a scalar.\n */\n\n\nfunction setValue(record, storageKey, value) {\n  if (process.env.NODE_ENV !== \"production\") {\n    var prevID = getDataID(record);\n\n    if (storageKey === ID_KEY) {\n      process.env.NODE_ENV !== \"production\" ? warning(prevID === value, 'RelayModernRecord: Invalid field update, expected both versions of ' + 'the record to have the same id, got `%s` and `%s`.', prevID, value) : void 0;\n    } else if (storageKey === TYPENAME_KEY) {\n      var _getType5; // note: coalesce null/undefined to null\n\n\n      var prevType = (_getType5 = getType(record)) !== null && _getType5 !== void 0 ? _getType5 : null;\n      var nextType = value !== null && value !== void 0 ? value : null;\n      process.env.NODE_ENV !== \"production\" ? warning(isClientID(getDataID(record)) && getDataID(record) !== ROOT_ID || prevType === nextType, 'RelayModernRecord: Invalid field update, expected both versions of ' + 'record `%s` to have the same `%s` but got conflicting types `%s` ' + 'and `%s`. The GraphQL server likely violated the globally unique ' + 'id requirement by returning the same id for different objects.', prevID, TYPENAME_KEY, prevType, nextType) : void 0;\n    }\n  }\n\n  record[storageKey] = value;\n}\n/**\n * @public\n *\n * Set the value of a field to a reference to another record.\n */\n\n\nfunction setLinkedRecordID(record, storageKey, linkedID) {\n  // See perf note above for why we aren't using computed property access.\n  var link = {};\n  link[REF_KEY] = linkedID;\n  record[storageKey] = link;\n}\n/**\n * @public\n *\n * Set the value of a field to a list of references other records.\n */\n\n\nfunction setLinkedRecordIDs(record, storageKey, linkedIDs) {\n  // See perf note above for why we aren't using computed property access.\n  var links = {};\n  links[REFS_KEY] = linkedIDs;\n  record[storageKey] = links;\n}\n/**\n * @public\n *\n * Set the value of a field to a reference to another record in the actor specific store.\n */\n\n\nfunction setActorLinkedRecordID(record, storageKey, actorIdentifier, linkedID) {\n  // See perf note above for why we aren't using computed property access.\n  var link = {};\n  link[REF_KEY] = linkedID;\n  link[ACTOR_IDENTIFIER_KEY] = actorIdentifier;\n  record[storageKey] = link;\n}\n/**\n * @public\n *\n * Get link to a record and the actor identifier for the store.\n */\n\n\nfunction getActorLinkedRecordID(record, storageKey) {\n  var link = record[storageKey];\n\n  if (link == null) {\n    return link;\n  }\n\n  !(typeof link === 'object' && typeof link[REF_KEY] === 'string' && link[ACTOR_IDENTIFIER_KEY] != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernRecord.getActorLinkedRecordID(): Expected `%s.%s` to be an actor specific linked ID, ' + 'was `%s`.', record[ID_KEY], storageKey, JSON.stringify(link)) : invariant(false) : void 0;\n  return [link[ACTOR_IDENTIFIER_KEY], link[REF_KEY]];\n}\n\nmodule.exports = {\n  clone: clone,\n  copyFields: copyFields,\n  create: create,\n  freeze: freeze,\n  getDataID: getDataID,\n  getInvalidationEpoch: getInvalidationEpoch,\n  getLinkedRecordID: getLinkedRecordID,\n  getLinkedRecordIDs: getLinkedRecordIDs,\n  getType: getType,\n  getValue: getValue,\n  merge: merge,\n  setValue: setValue,\n  setLinkedRecordID: setLinkedRecordID,\n  setLinkedRecordIDs: setLinkedRecordIDs,\n  update: update,\n  getActorLinkedRecordID: getActorLinkedRecordID,\n  setActorLinkedRecordID: setActorLinkedRecordID\n};","map":{"version":3,"sources":["/home/akshay/Atishay/appointy-screening/node_modules/relay-runtime/lib/store/RelayModernRecord.js"],"names":["_interopRequireDefault","require","_objectSpread2","areEqual","deepFreeze","invariant","warning","_require","isClientID","_require2","ACTOR_IDENTIFIER_KEY","ID_KEY","REF_KEY","REFS_KEY","TYPENAME_KEY","INVALIDATED_AT_KEY","ROOT_ID","clone","record","copyFields","source","sink","key","hasOwnProperty","create","dataID","typeName","getDataID","getType","getValue","storageKey","value","process","env","NODE_ENV","getLinkedRecordID","link","JSON","stringify","getLinkedRecordIDs","links","Array","isArray","getInvalidationEpoch","invalidatedAt","update","prevRecord","nextRecord","_getType","_getType2","prevID","nextID","prevType","nextType","updated","keys","Object","ii","length","merge","record1","record2","_getType3","_getType4","assign","freeze","setValue","_getType5","setLinkedRecordID","linkedID","setLinkedRecordIDs","linkedIDs","setActorLinkedRecordID","actorIdentifier","getActorLinkedRecordID","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread2\"));\n\nvar areEqual = require(\"fbjs/lib/areEqual\");\n\nvar deepFreeze = require('../util/deepFreeze');\n\nvar invariant = require('invariant');\n\nvar warning = require(\"fbjs/lib/warning\");\n\nvar _require = require('./ClientID'),\n    isClientID = _require.isClientID;\n\nvar _require2 = require('./RelayStoreUtils'),\n    ACTOR_IDENTIFIER_KEY = _require2.ACTOR_IDENTIFIER_KEY,\n    ID_KEY = _require2.ID_KEY,\n    REF_KEY = _require2.REF_KEY,\n    REFS_KEY = _require2.REFS_KEY,\n    TYPENAME_KEY = _require2.TYPENAME_KEY,\n    INVALIDATED_AT_KEY = _require2.INVALIDATED_AT_KEY,\n    ROOT_ID = _require2.ROOT_ID;\n\n/**\n * @public\n *\n * Low-level record manipulation methods.\n *\n * A note about perf: we use long-hand property access rather than computed\n * properties in this file for speed ie.\n *\n *    const object = {};\n *    object[KEY] = value;\n *    record[storageKey] = object;\n *\n * instead of:\n *\n *    record[storageKey] = {\n *      [KEY]: value,\n *    };\n *\n * The latter gets transformed by Babel into something like:\n *\n *    function _defineProperty(obj, key, value) {\n *      if (key in obj) {\n *        Object.defineProperty(obj, key, {\n *          value: value,\n *          enumerable: true,\n *          configurable: true,\n *          writable: true,\n *        });\n *      } else {\n *        obj[key] = value;\n *      }\n *      return obj;\n *    }\n *\n *    record[storageKey] = _defineProperty({}, KEY, value);\n *\n * A quick benchmark shows that computed property access is an order of\n * magnitude slower (times in seconds for 100,000 iterations):\n *\n *               best     avg     sd\n *    computed 0.02175 0.02292 0.00113\n *      manual 0.00110 0.00123 0.00008\n */\n\n/**\n * @public\n *\n * Clone a record.\n */\nfunction clone(record) {\n  return (0, _objectSpread2[\"default\"])({}, record);\n}\n/**\n * @public\n *\n * Copies all fields from `source` to `sink`, excluding `__id` and `__typename`.\n *\n * NOTE: This function does not treat `id` specially. To preserve the id,\n * manually reset it after calling this function. Also note that values are\n * copied by reference and not value; callers should ensure that values are\n * copied on write.\n */\n\n\nfunction copyFields(source, sink) {\n  for (var key in source) {\n    if (source.hasOwnProperty(key)) {\n      if (key !== ID_KEY && key !== TYPENAME_KEY) {\n        sink[key] = source[key];\n      }\n    }\n  }\n}\n/**\n * @public\n *\n * Create a new record.\n */\n\n\nfunction create(dataID, typeName) {\n  // See perf note above for why we aren't using computed property access.\n  var record = {};\n  record[ID_KEY] = dataID;\n  record[TYPENAME_KEY] = typeName;\n  return record;\n}\n/**\n * @public\n *\n * Get the record's `id` if available or the client-generated identifier.\n */\n\n\nfunction getDataID(record) {\n  return record[ID_KEY];\n}\n/**\n * @public\n *\n * Get the concrete type of the record.\n */\n\n\nfunction getType(record) {\n  return record[TYPENAME_KEY];\n}\n/**\n * @public\n *\n * Get a scalar (non-link) field value.\n */\n\n\nfunction getValue(record, storageKey) {\n  var value = record[storageKey];\n\n  if (value && typeof value === 'object') {\n    !(!value.hasOwnProperty(REF_KEY) && !value.hasOwnProperty(REFS_KEY)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernRecord.getValue(): Expected a scalar (non-link) value for `%s.%s` ' + 'but found %s.', record[ID_KEY], storageKey, value.hasOwnProperty(REF_KEY) ? 'a linked record' : 'plural linked records') : invariant(false) : void 0;\n  }\n\n  return value;\n}\n/**\n * @public\n *\n * Get the value of a field as a reference to another record. Throws if the\n * field has a different type.\n */\n\n\nfunction getLinkedRecordID(record, storageKey) {\n  var link = record[storageKey];\n\n  if (link == null) {\n    return link;\n  }\n\n  !(typeof link === 'object' && link && typeof link[REF_KEY] === 'string') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernRecord.getLinkedRecordID(): Expected `%s.%s` to be a linked ID, ' + 'was `%s`.', record[ID_KEY], storageKey, JSON.stringify(link)) : invariant(false) : void 0;\n  return link[REF_KEY];\n}\n/**\n * @public\n *\n * Get the value of a field as a list of references to other records. Throws if\n * the field has a different type.\n */\n\n\nfunction getLinkedRecordIDs(record, storageKey) {\n  var links = record[storageKey];\n\n  if (links == null) {\n    return links;\n  }\n\n  !(typeof links === 'object' && Array.isArray(links[REFS_KEY])) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernRecord.getLinkedRecordIDs(): Expected `%s.%s` to contain an array ' + 'of linked IDs, got `%s`.', record[ID_KEY], storageKey, JSON.stringify(links)) : invariant(false) : void 0; // assume items of the array are ids\n\n  return links[REFS_KEY];\n}\n/**\n * @public\n *\n * Returns the epoch at which the record was invalidated, if it\n * ever was; otherwise returns null;\n */\n\n\nfunction getInvalidationEpoch(record) {\n  if (record == null) {\n    return null;\n  }\n\n  var invalidatedAt = record[INVALIDATED_AT_KEY];\n\n  if (typeof invalidatedAt !== 'number') {\n    // If the record has never been invalidated, it isn't stale.\n    return null;\n  }\n\n  return invalidatedAt;\n}\n/**\n * @public\n *\n * Compares the fields of a previous and new record, returning either the\n * previous record if all fields are equal or a new record (with merged fields)\n * if any fields have changed.\n */\n\n\nfunction update(prevRecord, nextRecord) {\n  if (process.env.NODE_ENV !== \"production\") {\n    var _getType, _getType2;\n\n    var prevID = getDataID(prevRecord);\n    var nextID = getDataID(nextRecord);\n    process.env.NODE_ENV !== \"production\" ? warning(prevID === nextID, 'RelayModernRecord: Invalid record update, expected both versions of ' + 'the record to have the same id, got `%s` and `%s`.', prevID, nextID) : void 0; // note: coalesce null/undefined to null\n\n    var prevType = (_getType = getType(prevRecord)) !== null && _getType !== void 0 ? _getType : null;\n    var nextType = (_getType2 = getType(nextRecord)) !== null && _getType2 !== void 0 ? _getType2 : null;\n    process.env.NODE_ENV !== \"production\" ? warning(isClientID(nextID) && nextID !== ROOT_ID || prevType === nextType, 'RelayModernRecord: Invalid record update, expected both versions of ' + 'record `%s` to have the same `%s` but got conflicting types `%s` ' + 'and `%s`. The GraphQL server likely violated the globally unique ' + 'id requirement by returning the same id for different objects.', prevID, TYPENAME_KEY, prevType, nextType) : void 0;\n  }\n\n  var updated = null;\n  var keys = Object.keys(nextRecord);\n\n  for (var ii = 0; ii < keys.length; ii++) {\n    var key = keys[ii];\n\n    if (updated || !areEqual(prevRecord[key], nextRecord[key])) {\n      updated = updated !== null ? updated : (0, _objectSpread2[\"default\"])({}, prevRecord);\n      updated[key] = nextRecord[key];\n    }\n  }\n\n  return updated !== null ? updated : prevRecord;\n}\n/**\n * @public\n *\n * Returns a new record with the contents of the given records. Fields in the\n * second record will overwrite identical fields in the first record.\n */\n\n\nfunction merge(record1, record2) {\n  if (process.env.NODE_ENV !== \"production\") {\n    var _getType3, _getType4;\n\n    var prevID = getDataID(record1);\n    var nextID = getDataID(record2);\n    process.env.NODE_ENV !== \"production\" ? warning(prevID === nextID, 'RelayModernRecord: Invalid record merge, expected both versions of ' + 'the record to have the same id, got `%s` and `%s`.', prevID, nextID) : void 0; // note: coalesce null/undefined to null\n\n    var prevType = (_getType3 = getType(record1)) !== null && _getType3 !== void 0 ? _getType3 : null;\n    var nextType = (_getType4 = getType(record2)) !== null && _getType4 !== void 0 ? _getType4 : null;\n    process.env.NODE_ENV !== \"production\" ? warning(isClientID(nextID) && nextID !== ROOT_ID || prevType === nextType, 'RelayModernRecord: Invalid record merge, expected both versions of ' + 'record `%s` to have the same `%s` but got conflicting types `%s` ' + 'and `%s`. The GraphQL server likely violated the globally unique ' + 'id requirement by returning the same id for different objects.', prevID, TYPENAME_KEY, prevType, nextType) : void 0;\n  }\n\n  return Object.assign({}, record1, record2);\n}\n/**\n * @public\n *\n * Prevent modifications to the record. Attempts to call `set*` functions on a\n * frozen record will fatal at runtime.\n */\n\n\nfunction freeze(record) {\n  deepFreeze(record);\n}\n/**\n * @public\n *\n * Set the value of a storageKey to a scalar.\n */\n\n\nfunction setValue(record, storageKey, value) {\n  if (process.env.NODE_ENV !== \"production\") {\n    var prevID = getDataID(record);\n\n    if (storageKey === ID_KEY) {\n      process.env.NODE_ENV !== \"production\" ? warning(prevID === value, 'RelayModernRecord: Invalid field update, expected both versions of ' + 'the record to have the same id, got `%s` and `%s`.', prevID, value) : void 0;\n    } else if (storageKey === TYPENAME_KEY) {\n      var _getType5;\n\n      // note: coalesce null/undefined to null\n      var prevType = (_getType5 = getType(record)) !== null && _getType5 !== void 0 ? _getType5 : null;\n      var nextType = value !== null && value !== void 0 ? value : null;\n      process.env.NODE_ENV !== \"production\" ? warning(isClientID(getDataID(record)) && getDataID(record) !== ROOT_ID || prevType === nextType, 'RelayModernRecord: Invalid field update, expected both versions of ' + 'record `%s` to have the same `%s` but got conflicting types `%s` ' + 'and `%s`. The GraphQL server likely violated the globally unique ' + 'id requirement by returning the same id for different objects.', prevID, TYPENAME_KEY, prevType, nextType) : void 0;\n    }\n  }\n\n  record[storageKey] = value;\n}\n/**\n * @public\n *\n * Set the value of a field to a reference to another record.\n */\n\n\nfunction setLinkedRecordID(record, storageKey, linkedID) {\n  // See perf note above for why we aren't using computed property access.\n  var link = {};\n  link[REF_KEY] = linkedID;\n  record[storageKey] = link;\n}\n/**\n * @public\n *\n * Set the value of a field to a list of references other records.\n */\n\n\nfunction setLinkedRecordIDs(record, storageKey, linkedIDs) {\n  // See perf note above for why we aren't using computed property access.\n  var links = {};\n  links[REFS_KEY] = linkedIDs;\n  record[storageKey] = links;\n}\n/**\n * @public\n *\n * Set the value of a field to a reference to another record in the actor specific store.\n */\n\n\nfunction setActorLinkedRecordID(record, storageKey, actorIdentifier, linkedID) {\n  // See perf note above for why we aren't using computed property access.\n  var link = {};\n  link[REF_KEY] = linkedID;\n  link[ACTOR_IDENTIFIER_KEY] = actorIdentifier;\n  record[storageKey] = link;\n}\n/**\n * @public\n *\n * Get link to a record and the actor identifier for the store.\n */\n\n\nfunction getActorLinkedRecordID(record, storageKey) {\n  var link = record[storageKey];\n\n  if (link == null) {\n    return link;\n  }\n\n  !(typeof link === 'object' && typeof link[REF_KEY] === 'string' && link[ACTOR_IDENTIFIER_KEY] != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayModernRecord.getActorLinkedRecordID(): Expected `%s.%s` to be an actor specific linked ID, ' + 'was `%s`.', record[ID_KEY], storageKey, JSON.stringify(link)) : invariant(false) : void 0;\n  return [link[ACTOR_IDENTIFIER_KEY], link[REF_KEY]];\n}\n\nmodule.exports = {\n  clone: clone,\n  copyFields: copyFields,\n  create: create,\n  freeze: freeze,\n  getDataID: getDataID,\n  getInvalidationEpoch: getInvalidationEpoch,\n  getLinkedRecordID: getLinkedRecordID,\n  getLinkedRecordIDs: getLinkedRecordIDs,\n  getType: getType,\n  getValue: getValue,\n  merge: merge,\n  setValue: setValue,\n  setLinkedRecordID: setLinkedRecordID,\n  setLinkedRecordIDs: setLinkedRecordIDs,\n  update: update,\n  getActorLinkedRecordID: getActorLinkedRecordID,\n  setActorLinkedRecordID: setActorLinkedRecordID\n};"]},"metadata":{},"sourceType":"script"}