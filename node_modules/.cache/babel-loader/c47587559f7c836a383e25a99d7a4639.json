{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar invariant = require('invariant');\n\nvar _require = require('relay-runtime'),\n    createOperationDescriptor = _require.createOperationDescriptor,\n    isRelayModernEnvironment = _require.isRelayModernEnvironment,\n    fetchQuery = _require.__internal.fetchQuery;\n\nvar ReactRelayQueryFetcher = /*#__PURE__*/function () {\n  function ReactRelayQueryFetcher(args) {\n    (0, _defineProperty2[\"default\"])(this, \"_selectionReferences\", []);\n    (0, _defineProperty2[\"default\"])(this, \"_callOnDataChangeWhenSet\", false);\n\n    if (args != null) {\n      this._cacheSelectionReference = args.cacheSelectionReference;\n      this._selectionReferences = args.selectionReferences;\n    }\n  }\n\n  var _proto = ReactRelayQueryFetcher.prototype;\n\n  _proto.getSelectionReferences = function getSelectionReferences() {\n    return {\n      cacheSelectionReference: this._cacheSelectionReference,\n      selectionReferences: this._selectionReferences\n    };\n  };\n\n  _proto.lookupInStore = function lookupInStore(environment, operation, fetchPolicy) {\n    if (fetchPolicy === 'store-and-network' || fetchPolicy === 'store-or-network') {\n      if (environment.check(operation).status === 'available') {\n        this._retainCachedOperation(environment, operation);\n\n        return environment.lookup(operation.fragment);\n      }\n    }\n\n    return null;\n  };\n\n  _proto.execute = function execute(_ref) {\n    var _this = this;\n\n    var environment = _ref.environment,\n        operation = _ref.operation,\n        _ref$preservePrevious = _ref.preservePreviousReferences,\n        preservePreviousReferences = _ref$preservePrevious === void 0 ? false : _ref$preservePrevious;\n    var reference = environment.retain(operation);\n\n    var error = function error() {\n      // We may have partially fulfilled the request, so let the next request\n      // or the unmount dispose of the references.\n      _this._selectionReferences = _this._selectionReferences.concat(reference);\n    };\n\n    var complete = function complete() {\n      if (!preservePreviousReferences) {\n        _this.disposeSelectionReferences();\n      }\n\n      _this._selectionReferences = _this._selectionReferences.concat(reference);\n    };\n\n    var unsubscribe = function unsubscribe() {\n      // Let the next request or the unmount code dispose of the references.\n      // We may have partially fulfilled the request.\n      _this._selectionReferences = _this._selectionReferences.concat(reference);\n    };\n\n    if (!isRelayModernEnvironment(environment)) {\n      return environment.execute({\n        operation: operation\n      })[\"do\"]({\n        error: error,\n        complete: complete,\n        unsubscribe: unsubscribe\n      });\n    }\n\n    return fetchQuery(environment, operation)[\"do\"]({\n      error: error,\n      complete: complete,\n      unsubscribe: unsubscribe\n    });\n  };\n\n  _proto.setOnDataChange = function setOnDataChange(onDataChange) {\n    !this._fetchOptions ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayQueryFetcher: `setOnDataChange` should have been called after having called `fetch`') : invariant(false) : void 0;\n\n    if (typeof onDataChange === 'function') {\n      // Mutate the most recent fetchOptions in place,\n      // So that in-progress requests can access the updated callback.\n      this._fetchOptions.onDataChangeCallbacks = this._fetchOptions.onDataChangeCallbacks || [];\n\n      this._fetchOptions.onDataChangeCallbacks.push(onDataChange);\n\n      if (this._callOnDataChangeWhenSet) {\n        // We don't reset '_callOnDataChangeWhenSet' because another callback may be set\n        if (this._error != null) {\n          onDataChange({\n            error: this._error\n          });\n        } else if (this._snapshot != null) {\n          onDataChange({\n            snapshot: this._snapshot\n          });\n        }\n      }\n    }\n  }\n  /**\n   * `fetch` fetches the data for the given operation.\n   * If a result is immediately available synchronously, it will be synchronously\n   * returned by this function.\n   *\n   * Otherwise, the fetched result will be communicated via the `onDataChange` callback.\n   * `onDataChange` will be called with the first result (**if it wasn't returned synchronously**),\n   * and then subsequently whenever the data changes.\n   */\n  ;\n\n  _proto.fetch = function fetch(fetchOptions, cacheConfigOverride) {\n    var _this2 = this;\n\n    var environment = fetchOptions.environment,\n        operation = fetchOptions.operation,\n        onDataChange = fetchOptions.onDataChange;\n    var fetchHasReturned = false;\n\n    var _error;\n\n    this.disposeRequest();\n    var oldOnDataChangeCallbacks = this._fetchOptions && this._fetchOptions.onDataChangeCallbacks;\n    this._fetchOptions = {\n      environment: environment,\n      onDataChangeCallbacks: oldOnDataChangeCallbacks || [],\n      operation: operation\n    };\n\n    if (onDataChange && this._fetchOptions.onDataChangeCallbacks.indexOf(onDataChange) === -1) {\n      this._fetchOptions.onDataChangeCallbacks.push(onDataChange);\n    }\n\n    var operationOverride = cacheConfigOverride ? createOperationDescriptor(operation.request.node, operation.request.variables, cacheConfigOverride) : operation;\n    var request = this.execute({\n      environment: environment,\n      operation: operationOverride\n    })[\"finally\"](function () {\n      _this2._pendingRequest = null;\n    }).subscribe({\n      next: function next() {\n        // If we received a response,\n        // Make a note that to notify the callback when it's later added.\n        _this2._callOnDataChangeWhenSet = true;\n        _this2._error = null; // Only notify of the first result if `next` is being called **asynchronously**\n        // (i.e. after `fetch` has returned).\n\n        _this2._onQueryDataAvailable({\n          notifyFirstResult: fetchHasReturned\n        });\n      },\n      error: function error(err) {\n        // If we received a response when we didn't have a change callback,\n        // Make a note that to notify the callback when it's later added.\n        _this2._callOnDataChangeWhenSet = true;\n        _this2._error = err;\n        _this2._snapshot = null;\n        var onDataChangeCallbacks = _this2._fetchOptions && _this2._fetchOptions.onDataChangeCallbacks; // Only notify of error if `error` is being called **asynchronously**\n        // (i.e. after `fetch` has returned).\n\n        if (fetchHasReturned) {\n          if (onDataChangeCallbacks) {\n            onDataChangeCallbacks.forEach(function (onDataChange) {\n              onDataChange({\n                error: err\n              });\n            });\n          }\n        } else {\n          _error = err;\n        }\n      }\n    });\n    this._pendingRequest = {\n      dispose: function dispose() {\n        request.unsubscribe();\n      }\n    };\n    fetchHasReturned = true;\n\n    if (_error) {\n      throw _error;\n    }\n\n    return this._snapshot;\n  };\n\n  _proto.retry = function retry(cacheConfigOverride) {\n    !this._fetchOptions ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayQueryFetcher: `retry` should be called after having called `fetch`') : invariant(false) : void 0;\n    return this.fetch({\n      environment: this._fetchOptions.environment,\n      operation: this._fetchOptions.operation,\n      onDataChange: null // If there are onDataChangeCallbacks they will be reused\n\n    }, cacheConfigOverride);\n  };\n\n  _proto.dispose = function dispose() {\n    this.disposeRequest();\n    this.disposeSelectionReferences();\n  };\n\n  _proto.disposeRequest = function disposeRequest() {\n    this._error = null;\n    this._snapshot = null; // order is important, dispose of pendingFetch before selectionReferences\n\n    if (this._pendingRequest) {\n      this._pendingRequest.dispose();\n    }\n\n    if (this._rootSubscription) {\n      this._rootSubscription.dispose();\n\n      this._rootSubscription = null;\n    }\n  };\n\n  _proto._retainCachedOperation = function _retainCachedOperation(environment, operation) {\n    this._disposeCacheSelectionReference();\n\n    this._cacheSelectionReference = environment.retain(operation);\n  };\n\n  _proto._disposeCacheSelectionReference = function _disposeCacheSelectionReference() {\n    this._cacheSelectionReference && this._cacheSelectionReference.dispose();\n    this._cacheSelectionReference = null;\n  };\n\n  _proto.disposeSelectionReferences = function disposeSelectionReferences() {\n    this._disposeCacheSelectionReference();\n\n    this._selectionReferences.forEach(function (r) {\n      return r.dispose();\n    });\n\n    this._selectionReferences = [];\n  };\n\n  _proto._onQueryDataAvailable = function _onQueryDataAvailable(_ref2) {\n    var _this3 = this;\n\n    var notifyFirstResult = _ref2.notifyFirstResult;\n    !this._fetchOptions ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayQueryFetcher: `_onQueryDataAvailable` should have been called after having called `fetch`') : invariant(false) : void 0;\n    var _this$_fetchOptions = this._fetchOptions,\n        environment = _this$_fetchOptions.environment,\n        onDataChangeCallbacks = _this$_fetchOptions.onDataChangeCallbacks,\n        operation = _this$_fetchOptions.operation; // `_onQueryDataAvailable` can be called synchronously the first time and can be called\n    // multiple times by network layers that support data subscriptions.\n    // Wait until the first payload to call `onDataChange` and subscribe for data updates.\n\n    if (this._snapshot) {\n      return;\n    }\n\n    this._snapshot = environment.lookup(operation.fragment); // Subscribe to changes in the data of the root fragment\n\n    this._rootSubscription = environment.subscribe(this._snapshot, function (snapshot) {\n      // Read from this._fetchOptions in case onDataChange() was lazily added.\n      if (_this3._fetchOptions != null) {\n        var maybeNewOnDataChangeCallbacks = _this3._fetchOptions.onDataChangeCallbacks;\n\n        if (Array.isArray(maybeNewOnDataChangeCallbacks)) {\n          maybeNewOnDataChangeCallbacks.forEach(function (onDataChange) {\n            return onDataChange({\n              snapshot: snapshot\n            });\n          });\n        }\n      }\n    });\n\n    if (this._snapshot && notifyFirstResult && Array.isArray(onDataChangeCallbacks)) {\n      var snapshot = this._snapshot;\n      onDataChangeCallbacks.forEach(function (onDataChange) {\n        return onDataChange({\n          snapshot: snapshot\n        });\n      });\n    }\n  };\n\n  return ReactRelayQueryFetcher;\n}();\n\nmodule.exports = ReactRelayQueryFetcher;","map":{"version":3,"sources":["/home/akshay/Atishay/appointy-screening/node_modules/react-relay/lib/ReactRelayQueryFetcher.js"],"names":["_interopRequireDefault","require","_defineProperty2","invariant","_require","createOperationDescriptor","isRelayModernEnvironment","fetchQuery","__internal","ReactRelayQueryFetcher","args","_cacheSelectionReference","cacheSelectionReference","_selectionReferences","selectionReferences","_proto","prototype","getSelectionReferences","lookupInStore","environment","operation","fetchPolicy","check","status","_retainCachedOperation","lookup","fragment","execute","_ref","_this","_ref$preservePrevious","preservePreviousReferences","reference","retain","error","concat","complete","disposeSelectionReferences","unsubscribe","setOnDataChange","onDataChange","_fetchOptions","process","env","NODE_ENV","onDataChangeCallbacks","push","_callOnDataChangeWhenSet","_error","_snapshot","snapshot","fetch","fetchOptions","cacheConfigOverride","_this2","fetchHasReturned","disposeRequest","oldOnDataChangeCallbacks","indexOf","operationOverride","request","node","variables","_pendingRequest","subscribe","next","_onQueryDataAvailable","notifyFirstResult","err","forEach","dispose","retry","_rootSubscription","_disposeCacheSelectionReference","r","_ref2","_this3","_this$_fetchOptions","maybeNewOnDataChangeCallbacks","Array","isArray","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar invariant = require('invariant');\n\nvar _require = require('relay-runtime'),\n    createOperationDescriptor = _require.createOperationDescriptor,\n    isRelayModernEnvironment = _require.isRelayModernEnvironment,\n    fetchQuery = _require.__internal.fetchQuery;\n\nvar ReactRelayQueryFetcher = /*#__PURE__*/function () {\n  function ReactRelayQueryFetcher(args) {\n    (0, _defineProperty2[\"default\"])(this, \"_selectionReferences\", []);\n    (0, _defineProperty2[\"default\"])(this, \"_callOnDataChangeWhenSet\", false);\n\n    if (args != null) {\n      this._cacheSelectionReference = args.cacheSelectionReference;\n      this._selectionReferences = args.selectionReferences;\n    }\n  }\n\n  var _proto = ReactRelayQueryFetcher.prototype;\n\n  _proto.getSelectionReferences = function getSelectionReferences() {\n    return {\n      cacheSelectionReference: this._cacheSelectionReference,\n      selectionReferences: this._selectionReferences\n    };\n  };\n\n  _proto.lookupInStore = function lookupInStore(environment, operation, fetchPolicy) {\n    if (fetchPolicy === 'store-and-network' || fetchPolicy === 'store-or-network') {\n      if (environment.check(operation).status === 'available') {\n        this._retainCachedOperation(environment, operation);\n\n        return environment.lookup(operation.fragment);\n      }\n    }\n\n    return null;\n  };\n\n  _proto.execute = function execute(_ref) {\n    var _this = this;\n\n    var environment = _ref.environment,\n        operation = _ref.operation,\n        _ref$preservePrevious = _ref.preservePreviousReferences,\n        preservePreviousReferences = _ref$preservePrevious === void 0 ? false : _ref$preservePrevious;\n    var reference = environment.retain(operation);\n\n    var error = function error() {\n      // We may have partially fulfilled the request, so let the next request\n      // or the unmount dispose of the references.\n      _this._selectionReferences = _this._selectionReferences.concat(reference);\n    };\n\n    var complete = function complete() {\n      if (!preservePreviousReferences) {\n        _this.disposeSelectionReferences();\n      }\n\n      _this._selectionReferences = _this._selectionReferences.concat(reference);\n    };\n\n    var unsubscribe = function unsubscribe() {\n      // Let the next request or the unmount code dispose of the references.\n      // We may have partially fulfilled the request.\n      _this._selectionReferences = _this._selectionReferences.concat(reference);\n    };\n\n    if (!isRelayModernEnvironment(environment)) {\n      return environment.execute({\n        operation: operation\n      })[\"do\"]({\n        error: error,\n        complete: complete,\n        unsubscribe: unsubscribe\n      });\n    }\n\n    return fetchQuery(environment, operation)[\"do\"]({\n      error: error,\n      complete: complete,\n      unsubscribe: unsubscribe\n    });\n  };\n\n  _proto.setOnDataChange = function setOnDataChange(onDataChange) {\n    !this._fetchOptions ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayQueryFetcher: `setOnDataChange` should have been called after having called `fetch`') : invariant(false) : void 0;\n\n    if (typeof onDataChange === 'function') {\n      // Mutate the most recent fetchOptions in place,\n      // So that in-progress requests can access the updated callback.\n      this._fetchOptions.onDataChangeCallbacks = this._fetchOptions.onDataChangeCallbacks || [];\n\n      this._fetchOptions.onDataChangeCallbacks.push(onDataChange);\n\n      if (this._callOnDataChangeWhenSet) {\n        // We don't reset '_callOnDataChangeWhenSet' because another callback may be set\n        if (this._error != null) {\n          onDataChange({\n            error: this._error\n          });\n        } else if (this._snapshot != null) {\n          onDataChange({\n            snapshot: this._snapshot\n          });\n        }\n      }\n    }\n  }\n  /**\n   * `fetch` fetches the data for the given operation.\n   * If a result is immediately available synchronously, it will be synchronously\n   * returned by this function.\n   *\n   * Otherwise, the fetched result will be communicated via the `onDataChange` callback.\n   * `onDataChange` will be called with the first result (**if it wasn't returned synchronously**),\n   * and then subsequently whenever the data changes.\n   */\n  ;\n\n  _proto.fetch = function fetch(fetchOptions, cacheConfigOverride) {\n    var _this2 = this;\n\n    var environment = fetchOptions.environment,\n        operation = fetchOptions.operation,\n        onDataChange = fetchOptions.onDataChange;\n    var fetchHasReturned = false;\n\n    var _error;\n\n    this.disposeRequest();\n    var oldOnDataChangeCallbacks = this._fetchOptions && this._fetchOptions.onDataChangeCallbacks;\n    this._fetchOptions = {\n      environment: environment,\n      onDataChangeCallbacks: oldOnDataChangeCallbacks || [],\n      operation: operation\n    };\n\n    if (onDataChange && this._fetchOptions.onDataChangeCallbacks.indexOf(onDataChange) === -1) {\n      this._fetchOptions.onDataChangeCallbacks.push(onDataChange);\n    }\n\n    var operationOverride = cacheConfigOverride ? createOperationDescriptor(operation.request.node, operation.request.variables, cacheConfigOverride) : operation;\n    var request = this.execute({\n      environment: environment,\n      operation: operationOverride\n    })[\"finally\"](function () {\n      _this2._pendingRequest = null;\n    }).subscribe({\n      next: function next() {\n        // If we received a response,\n        // Make a note that to notify the callback when it's later added.\n        _this2._callOnDataChangeWhenSet = true;\n        _this2._error = null; // Only notify of the first result if `next` is being called **asynchronously**\n        // (i.e. after `fetch` has returned).\n\n        _this2._onQueryDataAvailable({\n          notifyFirstResult: fetchHasReturned\n        });\n      },\n      error: function error(err) {\n        // If we received a response when we didn't have a change callback,\n        // Make a note that to notify the callback when it's later added.\n        _this2._callOnDataChangeWhenSet = true;\n        _this2._error = err;\n        _this2._snapshot = null;\n        var onDataChangeCallbacks = _this2._fetchOptions && _this2._fetchOptions.onDataChangeCallbacks; // Only notify of error if `error` is being called **asynchronously**\n        // (i.e. after `fetch` has returned).\n\n        if (fetchHasReturned) {\n          if (onDataChangeCallbacks) {\n            onDataChangeCallbacks.forEach(function (onDataChange) {\n              onDataChange({\n                error: err\n              });\n            });\n          }\n        } else {\n          _error = err;\n        }\n      }\n    });\n    this._pendingRequest = {\n      dispose: function dispose() {\n        request.unsubscribe();\n      }\n    };\n    fetchHasReturned = true;\n\n    if (_error) {\n      throw _error;\n    }\n\n    return this._snapshot;\n  };\n\n  _proto.retry = function retry(cacheConfigOverride) {\n    !this._fetchOptions ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayQueryFetcher: `retry` should be called after having called `fetch`') : invariant(false) : void 0;\n    return this.fetch({\n      environment: this._fetchOptions.environment,\n      operation: this._fetchOptions.operation,\n      onDataChange: null // If there are onDataChangeCallbacks they will be reused\n\n    }, cacheConfigOverride);\n  };\n\n  _proto.dispose = function dispose() {\n    this.disposeRequest();\n    this.disposeSelectionReferences();\n  };\n\n  _proto.disposeRequest = function disposeRequest() {\n    this._error = null;\n    this._snapshot = null; // order is important, dispose of pendingFetch before selectionReferences\n\n    if (this._pendingRequest) {\n      this._pendingRequest.dispose();\n    }\n\n    if (this._rootSubscription) {\n      this._rootSubscription.dispose();\n\n      this._rootSubscription = null;\n    }\n  };\n\n  _proto._retainCachedOperation = function _retainCachedOperation(environment, operation) {\n    this._disposeCacheSelectionReference();\n\n    this._cacheSelectionReference = environment.retain(operation);\n  };\n\n  _proto._disposeCacheSelectionReference = function _disposeCacheSelectionReference() {\n    this._cacheSelectionReference && this._cacheSelectionReference.dispose();\n    this._cacheSelectionReference = null;\n  };\n\n  _proto.disposeSelectionReferences = function disposeSelectionReferences() {\n    this._disposeCacheSelectionReference();\n\n    this._selectionReferences.forEach(function (r) {\n      return r.dispose();\n    });\n\n    this._selectionReferences = [];\n  };\n\n  _proto._onQueryDataAvailable = function _onQueryDataAvailable(_ref2) {\n    var _this3 = this;\n\n    var notifyFirstResult = _ref2.notifyFirstResult;\n    !this._fetchOptions ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ReactRelayQueryFetcher: `_onQueryDataAvailable` should have been called after having called `fetch`') : invariant(false) : void 0;\n    var _this$_fetchOptions = this._fetchOptions,\n        environment = _this$_fetchOptions.environment,\n        onDataChangeCallbacks = _this$_fetchOptions.onDataChangeCallbacks,\n        operation = _this$_fetchOptions.operation; // `_onQueryDataAvailable` can be called synchronously the first time and can be called\n    // multiple times by network layers that support data subscriptions.\n    // Wait until the first payload to call `onDataChange` and subscribe for data updates.\n\n    if (this._snapshot) {\n      return;\n    }\n\n    this._snapshot = environment.lookup(operation.fragment); // Subscribe to changes in the data of the root fragment\n\n    this._rootSubscription = environment.subscribe(this._snapshot, function (snapshot) {\n      // Read from this._fetchOptions in case onDataChange() was lazily added.\n      if (_this3._fetchOptions != null) {\n        var maybeNewOnDataChangeCallbacks = _this3._fetchOptions.onDataChangeCallbacks;\n\n        if (Array.isArray(maybeNewOnDataChangeCallbacks)) {\n          maybeNewOnDataChangeCallbacks.forEach(function (onDataChange) {\n            return onDataChange({\n              snapshot: snapshot\n            });\n          });\n        }\n      }\n    });\n\n    if (this._snapshot && notifyFirstResult && Array.isArray(onDataChangeCallbacks)) {\n      var snapshot = this._snapshot;\n      onDataChangeCallbacks.forEach(function (onDataChange) {\n        return onDataChange({\n          snapshot: snapshot\n        });\n      });\n    }\n  };\n\n  return ReactRelayQueryFetcher;\n}();\n\nmodule.exports = ReactRelayQueryFetcher;"]},"metadata":{},"sourceType":"script"}