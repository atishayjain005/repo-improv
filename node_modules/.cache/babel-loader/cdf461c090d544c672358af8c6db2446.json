{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar ClientID = require('./ClientID');\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar invariant = require('invariant');\n\nvar _require = require('../util/RelayConcreteNode'),\n    ACTOR_CHANGE = _require.ACTOR_CHANGE,\n    CLIENT_EXTENSION = _require.CLIENT_EXTENSION,\n    CONDITION = _require.CONDITION,\n    DEFER = _require.DEFER,\n    FLIGHT_FIELD = _require.FLIGHT_FIELD,\n    FRAGMENT_SPREAD = _require.FRAGMENT_SPREAD,\n    INLINE_DATA_FRAGMENT_SPREAD = _require.INLINE_DATA_FRAGMENT_SPREAD,\n    INLINE_FRAGMENT = _require.INLINE_FRAGMENT,\n    LINKED_FIELD = _require.LINKED_FIELD,\n    MODULE_IMPORT = _require.MODULE_IMPORT,\n    REQUIRED_FIELD = _require.REQUIRED_FIELD,\n    RELAY_RESOLVER = _require.RELAY_RESOLVER,\n    SCALAR_FIELD = _require.SCALAR_FIELD,\n    STREAM = _require.STREAM;\n\nvar _require2 = require('./RelayStoreReactFlightUtils'),\n    getReactFlightClientResponse = _require2.getReactFlightClientResponse;\n\nvar _require3 = require('./RelayStoreUtils'),\n    FRAGMENTS_KEY = _require3.FRAGMENTS_KEY,\n    FRAGMENT_OWNER_KEY = _require3.FRAGMENT_OWNER_KEY,\n    FRAGMENT_PROP_NAME_KEY = _require3.FRAGMENT_PROP_NAME_KEY,\n    ID_KEY = _require3.ID_KEY,\n    IS_WITHIN_UNMATCHED_TYPE_REFINEMENT = _require3.IS_WITHIN_UNMATCHED_TYPE_REFINEMENT,\n    MODULE_COMPONENT_KEY = _require3.MODULE_COMPONENT_KEY,\n    ROOT_ID = _require3.ROOT_ID,\n    getArgumentValues = _require3.getArgumentValues,\n    getStorageKey = _require3.getStorageKey,\n    getModuleComponentKey = _require3.getModuleComponentKey;\n\nvar _require4 = require('./ResolverCache'),\n    NoopResolverCache = _require4.NoopResolverCache;\n\nvar _require5 = require('./ResolverFragments'),\n    withResolverContext = _require5.withResolverContext;\n\nvar _require6 = require('./TypeID'),\n    generateTypeID = _require6.generateTypeID;\n\nfunction read(recordSource, selector, resolverCache) {\n  var reader = new RelayReader(recordSource, selector, resolverCache !== null && resolverCache !== void 0 ? resolverCache : new NoopResolverCache());\n  return reader.read();\n}\n/**\n * @private\n */\n\n\nvar RelayReader = /*#__PURE__*/function () {\n  function RelayReader(recordSource, selector, resolverCache) {\n    this._isMissingData = false;\n    this._isWithinUnmatchedTypeRefinement = false;\n    this._missingRequiredFields = null;\n    this._owner = selector.owner;\n    this._recordSource = recordSource;\n    this._seenRecords = new Set();\n    this._selector = selector;\n    this._variables = selector.variables;\n    this._resolverCache = resolverCache;\n  }\n\n  var _proto = RelayReader.prototype;\n\n  _proto.read = function read() {\n    var _this$_selector = this._selector,\n        node = _this$_selector.node,\n        dataID = _this$_selector.dataID,\n        isWithinUnmatchedTypeRefinement = _this$_selector.isWithinUnmatchedTypeRefinement;\n    var abstractKey = node.abstractKey;\n\n    var record = this._recordSource.get(dataID); // Relay historically allowed child fragments to be read even if the root object\n    // did not match the type of the fragment: either the root object has a different\n    // concrete type than the fragment (for concrete fragments) or the root object does\n    // not conform to the interface/union for abstract fragments.\n    // For suspense purposes, however, we want to accurately compute whether any data\n    // is missing: but if the fragment type doesn't match (or a parent type didn't\n    // match), then no data is expected to be present.\n    // By default data is expected to be present unless this selector was read out\n    // from within a non-matching type refinement in a parent fragment:\n\n\n    var isDataExpectedToBePresent = !isWithinUnmatchedTypeRefinement; // If this is a concrete fragment and the concrete type of the record does not\n    // match, then no data is expected to be present.\n\n    if (isDataExpectedToBePresent && abstractKey == null && record != null) {\n      var recordType = RelayModernRecord.getType(record);\n\n      if (recordType !== node.type && // The root record type is a special `__Root` type and may not match the\n      // type on the ast, so ignore type mismatches at the root.\n      // We currently detect whether we're at the root by checking against ROOT_ID,\n      // but this does not work for mutations/subscriptions which generate unique\n      // root ids. This is acceptable in practice as we don't read data for mutations/\n      // subscriptions in a situation where we would use isMissingData to decide whether\n      // to suspend or not.\n      // TODO T96653810: Correctly detect reading from root of mutation/subscription\n      dataID !== ROOT_ID) {\n        isDataExpectedToBePresent = false;\n      }\n    } // If this is an abstract fragment (and the precise refinement GK is enabled)\n    // then data is only expected to be present if the record type is known to\n    // implement the interface. If we aren't sure whether the record implements\n    // the interface, that itself constitutes \"expected\" data being missing.\n\n\n    if (isDataExpectedToBePresent && abstractKey != null && record != null) {\n      var _recordType = RelayModernRecord.getType(record);\n\n      var typeID = generateTypeID(_recordType);\n\n      var typeRecord = this._recordSource.get(typeID);\n\n      var implementsInterface = typeRecord != null ? RelayModernRecord.getValue(typeRecord, abstractKey) : null;\n\n      if (implementsInterface === false) {\n        // Type known to not implement the interface\n        isDataExpectedToBePresent = false;\n      } else if (implementsInterface == null) {\n        // Don't know if the type implements the interface or not\n        this._isMissingData = true;\n      }\n    }\n\n    this._isWithinUnmatchedTypeRefinement = !isDataExpectedToBePresent;\n\n    var data = this._traverse(node, dataID, null);\n\n    return {\n      data: data,\n      isMissingData: this._isMissingData && isDataExpectedToBePresent,\n      seenRecords: this._seenRecords,\n      selector: this._selector,\n      missingRequiredFields: this._missingRequiredFields\n    };\n  };\n\n  _proto._traverse = function _traverse(node, dataID, prevData) {\n    var record = this._recordSource.get(dataID);\n\n    this._seenRecords.add(dataID);\n\n    if (record == null) {\n      if (record === undefined) {\n        this._isMissingData = true;\n      }\n\n      return record;\n    }\n\n    var data = prevData || {};\n\n    var hadRequiredData = this._traverseSelections(node.selections, record, data);\n\n    return hadRequiredData ? data : null;\n  };\n\n  _proto._getVariableValue = function _getVariableValue(name) {\n    !this._variables.hasOwnProperty(name) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Undefined variable `%s`.', name) : invariant(false) : void 0; // $FlowFixMe[cannot-write]\n\n    return this._variables[name];\n  };\n\n  _proto._maybeReportUnexpectedNull = function _maybeReportUnexpectedNull(fieldPath, action, record) {\n    var _this$_missingRequire;\n\n    if (((_this$_missingRequire = this._missingRequiredFields) === null || _this$_missingRequire === void 0 ? void 0 : _this$_missingRequire.action) === 'THROW') {\n      // Chained @required directives may cause a parent `@required(action:\n      // THROW)` field to become null, so the first missing field we\n      // encounter is likely to be the root cause of the error.\n      return;\n    }\n\n    var owner = this._selector.node.name;\n\n    switch (action) {\n      case 'THROW':\n        this._missingRequiredFields = {\n          action: action,\n          field: {\n            path: fieldPath,\n            owner: owner\n          }\n        };\n        return;\n\n      case 'LOG':\n        if (this._missingRequiredFields == null) {\n          this._missingRequiredFields = {\n            action: action,\n            fields: []\n          };\n        }\n\n        this._missingRequiredFields.fields.push({\n          path: fieldPath,\n          owner: owner\n        });\n\n        return;\n\n      default:\n        action;\n    }\n  };\n\n  _proto._traverseSelections = function _traverseSelections(selections, record, data)\n  /* had all expected data */\n  {\n    for (var i = 0; i < selections.length; i++) {\n      var selection = selections[i];\n\n      switch (selection.kind) {\n        case REQUIRED_FIELD:\n          !RelayFeatureFlags.ENABLE_REQUIRED_DIRECTIVES ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Encountered a `@required` directive at path \"%s\" in `%s` without the `ENABLE_REQUIRED_DIRECTIVES` feature flag enabled.', selection.path, this._selector.node.name) : invariant(false) : void 0;\n\n          var fieldValue = this._readRequiredField(selection, record, data);\n\n          if (fieldValue == null) {\n            var action = selection.action;\n\n            if (action !== 'NONE') {\n              this._maybeReportUnexpectedNull(selection.path, action, record);\n            } // We are going to throw, or our parent is going to get nulled out.\n            // Either way, sibling values are going to be ignored, so we can\n            // bail early here as an optimization.\n\n\n            return false;\n          }\n\n          break;\n\n        case SCALAR_FIELD:\n          this._readScalar(selection, record, data);\n\n          break;\n\n        case LINKED_FIELD:\n          if (selection.plural) {\n            this._readPluralLink(selection, record, data);\n          } else {\n            this._readLink(selection, record, data);\n          }\n\n          break;\n\n        case CONDITION:\n          var conditionValue = Boolean(this._getVariableValue(selection.condition));\n\n          if (conditionValue === selection.passingValue) {\n            var hasExpectedData = this._traverseSelections(selection.selections, record, data);\n\n            if (!hasExpectedData) {\n              return false;\n            }\n          }\n\n          break;\n\n        case INLINE_FRAGMENT:\n          {\n            var abstractKey = selection.abstractKey;\n\n            if (abstractKey == null) {\n              // concrete type refinement: only read data if the type exactly matches\n              var typeName = RelayModernRecord.getType(record);\n\n              if (typeName != null && typeName === selection.type) {\n                var _hasExpectedData = this._traverseSelections(selection.selections, record, data);\n\n                if (!_hasExpectedData) {\n                  return false;\n                }\n              }\n            } else {\n              // Similar to the logic in read(): data is only expected to be present\n              // if the record is known to conform to the interface. If we don't know\n              // whether the type conforms or not, that constitutes missing data.\n              // store flags to reset after reading\n              var parentIsMissingData = this._isMissingData;\n              var parentIsWithinUnmatchedTypeRefinement = this._isWithinUnmatchedTypeRefinement;\n\n              var _typeName = RelayModernRecord.getType(record);\n\n              var typeID = generateTypeID(_typeName);\n\n              var typeRecord = this._recordSource.get(typeID);\n\n              var implementsInterface = typeRecord != null ? RelayModernRecord.getValue(typeRecord, abstractKey) : null;\n              this._isWithinUnmatchedTypeRefinement = parentIsWithinUnmatchedTypeRefinement || implementsInterface === false;\n\n              this._traverseSelections(selection.selections, record, data);\n\n              this._isWithinUnmatchedTypeRefinement = parentIsWithinUnmatchedTypeRefinement;\n\n              if (implementsInterface === false) {\n                // Type known to not implement the interface, no data expected\n                this._isMissingData = parentIsMissingData;\n              } else if (implementsInterface == null) {\n                // Don't know if the type implements the interface or not\n                this._isMissingData = true;\n              }\n            }\n\n            break;\n          }\n\n        case RELAY_RESOLVER:\n          {\n            if (!RelayFeatureFlags.ENABLE_RELAY_RESOLVERS) {\n              throw new Error('Relay Resolver fields are not yet supported.');\n            }\n\n            this._readResolverField(selection, record, data);\n\n            break;\n          }\n\n        case FRAGMENT_SPREAD:\n          this._createFragmentPointer(selection, record, data);\n\n          break;\n\n        case MODULE_IMPORT:\n          this._readModuleImport(selection, record, data);\n\n          break;\n\n        case INLINE_DATA_FRAGMENT_SPREAD:\n          this._createInlineDataOrResolverFragmentPointer(selection, record, data);\n\n          break;\n\n        case DEFER:\n        case CLIENT_EXTENSION:\n          {\n            var isMissingData = this._isMissingData;\n\n            var _hasExpectedData2 = this._traverseSelections(selection.selections, record, data);\n\n            this._isMissingData = isMissingData;\n\n            if (!_hasExpectedData2) {\n              return false;\n            }\n\n            break;\n          }\n\n        case STREAM:\n          {\n            var _hasExpectedData3 = this._traverseSelections(selection.selections, record, data);\n\n            if (!_hasExpectedData3) {\n              return false;\n            }\n\n            break;\n          }\n\n        case FLIGHT_FIELD:\n          if (RelayFeatureFlags.ENABLE_REACT_FLIGHT_COMPONENT_FIELD) {\n            this._readFlightField(selection, record, data);\n          } else {\n            throw new Error('Flight fields are not yet supported.');\n          }\n\n          break;\n\n        case ACTOR_CHANGE:\n          this._readActorChange(selection, record, data);\n\n          break;\n\n        default:\n          selection;\n          !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Unexpected ast kind `%s`.', selection.kind) : invariant(false) : void 0;\n      }\n    }\n\n    return true;\n  };\n\n  _proto._readRequiredField = function _readRequiredField(selection, record, data) {\n    switch (selection.field.kind) {\n      case SCALAR_FIELD:\n        return this._readScalar(selection.field, record, data);\n\n      case LINKED_FIELD:\n        if (selection.field.plural) {\n          return this._readPluralLink(selection.field, record, data);\n        } else {\n          return this._readLink(selection.field, record, data);\n        }\n\n      case RELAY_RESOLVER:\n        if (!RelayFeatureFlags.ENABLE_RELAY_RESOLVERS) {\n          throw new Error('Relay Resolver fields are not yet supported.');\n        }\n\n        this._readResolverField(selection.field, record, data);\n\n        break;\n\n      default:\n        selection.field.kind;\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Unexpected ast kind `%s`.', selection.kind) : invariant(false) : void 0;\n    }\n  };\n\n  _proto._readResolverField = function _readResolverField(field, record, data) {\n    var _this = this;\n\n    var resolverModule = field.resolverModule,\n        fragment = field.fragment;\n    var storageKey = getStorageKey(field, this._variables);\n    var resolverID = ClientID.generateClientID(RelayModernRecord.getDataID(record), storageKey); // Found when reading the resolver fragment, which can happen either when\n    // evaluating the resolver and it calls readFragment, or when checking if the\n    // inputs have changed since a previous evaluation:\n\n    var fragmentValue;\n    var fragmentReaderSelector;\n    var fragmentSeenRecordIDs = new Set();\n\n    var getDataForResolverFragment = function getDataForResolverFragment(singularReaderSelector) {\n      if (fragmentValue != null) {\n        // It was already read when checking for input staleness; no need to read it again.\n        // Note that the variables like fragmentSeenRecordIDs in the outer closure will have\n        // already been set and will still be used in this case.\n        return fragmentValue;\n      }\n\n      fragmentReaderSelector = singularReaderSelector;\n      var existingSeenRecords = _this._seenRecords;\n\n      try {\n        var _resolverFragmentData;\n\n        _this._seenRecords = fragmentSeenRecordIDs;\n        var resolverFragmentData = {};\n\n        _this._createInlineDataOrResolverFragmentPointer(singularReaderSelector.node, record, resolverFragmentData);\n\n        fragmentValue = (_resolverFragmentData = resolverFragmentData[FRAGMENTS_KEY]) === null || _resolverFragmentData === void 0 ? void 0 : _resolverFragmentData[fragment.name];\n        !(typeof fragmentValue === 'object' && fragmentValue !== null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Expected reader data to contain a __fragments property with a property for the fragment named \".concat(fragment.name, \", but it is missing.\")) : invariant(false) : void 0;\n        return fragmentValue;\n      } finally {\n        _this._seenRecords = existingSeenRecords;\n      }\n    };\n\n    var resolverContext = {\n      getDataForResolverFragment: getDataForResolverFragment\n    };\n\n    var _this$_resolverCache$ = this._resolverCache.readFromCacheOrEvaluate(record, field, this._variables, function () {\n      var key = {\n        __id: RelayModernRecord.getDataID(record),\n        __fragmentOwner: _this._owner,\n        __fragments: (0, _defineProperty2[\"default\"])({}, fragment.name, {})\n      };\n      return withResolverContext(resolverContext, function () {\n        // $FlowFixMe[prop-missing] - resolver module's type signature is a lie\n        var resolverResult = resolverModule(key);\n        return {\n          resolverResult: resolverResult,\n          fragmentValue: fragmentValue,\n          resolverID: resolverID,\n          seenRecordIDs: fragmentSeenRecordIDs,\n          readerSelector: fragmentReaderSelector\n        };\n      });\n    }, getDataForResolverFragment),\n        result = _this$_resolverCache$[0],\n        seenRecord = _this$_resolverCache$[1];\n\n    if (seenRecord != null) {\n      this._seenRecords.add(seenRecord);\n    }\n\n    data[storageKey] = result;\n    return result;\n  };\n\n  _proto._readFlightField = function _readFlightField(field, record, data) {\n    var _field$alias;\n\n    var applicationName = (_field$alias = field.alias) !== null && _field$alias !== void 0 ? _field$alias : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var reactFlightClientResponseRecordID = RelayModernRecord.getLinkedRecordID(record, storageKey);\n\n    if (reactFlightClientResponseRecordID == null) {\n      data[applicationName] = reactFlightClientResponseRecordID;\n\n      if (reactFlightClientResponseRecordID === undefined) {\n        this._isMissingData = true;\n      }\n\n      return reactFlightClientResponseRecordID;\n    }\n\n    var reactFlightClientResponseRecord = this._recordSource.get(reactFlightClientResponseRecordID);\n\n    this._seenRecords.add(reactFlightClientResponseRecordID);\n\n    if (reactFlightClientResponseRecord == null) {\n      data[applicationName] = reactFlightClientResponseRecord;\n\n      if (reactFlightClientResponseRecord === undefined) {\n        this._isMissingData = true;\n      }\n\n      return reactFlightClientResponseRecord;\n    }\n\n    var clientResponse = getReactFlightClientResponse(reactFlightClientResponseRecord);\n    data[applicationName] = clientResponse;\n    return clientResponse;\n  };\n\n  _proto._readScalar = function _readScalar(field, record, data) {\n    var _field$alias2;\n\n    var applicationName = (_field$alias2 = field.alias) !== null && _field$alias2 !== void 0 ? _field$alias2 : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var value = RelayModernRecord.getValue(record, storageKey);\n\n    if (value === undefined) {\n      this._isMissingData = true;\n    }\n\n    data[applicationName] = value;\n    return value;\n  };\n\n  _proto._readLink = function _readLink(field, record, data) {\n    var _field$alias3;\n\n    var applicationName = (_field$alias3 = field.alias) !== null && _field$alias3 !== void 0 ? _field$alias3 : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var linkedID = RelayModernRecord.getLinkedRecordID(record, storageKey);\n\n    if (linkedID == null) {\n      data[applicationName] = linkedID;\n\n      if (linkedID === undefined) {\n        this._isMissingData = true;\n      }\n\n      return linkedID;\n    }\n\n    var prevData = data[applicationName];\n    !(prevData == null || typeof prevData === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an object, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevData) : invariant(false) : void 0; // $FlowFixMe[incompatible-variance]\n\n    var value = this._traverse(field, linkedID, prevData);\n\n    data[applicationName] = value;\n    return value;\n  };\n\n  _proto._readActorChange = function _readActorChange(field, record, data) {\n    var _field$alias4;\n\n    var applicationName = (_field$alias4 = field.alias) !== null && _field$alias4 !== void 0 ? _field$alias4 : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var externalRef = RelayModernRecord.getActorLinkedRecordID(record, storageKey);\n\n    if (externalRef == null) {\n      data[applicationName] = externalRef;\n\n      if (externalRef === undefined) {\n        this._isMissingData = true;\n      }\n\n      return data[applicationName];\n    }\n\n    var actorIdentifier = externalRef[0],\n        dataID = externalRef[1];\n    var fragmentRef = {};\n\n    this._createFragmentPointer(field.fragmentSpread, {\n      __id: dataID\n    }, fragmentRef);\n\n    data[applicationName] = {\n      __fragmentRef: fragmentRef,\n      __viewer: actorIdentifier\n    };\n    return data[applicationName];\n  };\n\n  _proto._readPluralLink = function _readPluralLink(field, record, data) {\n    var _this2 = this;\n\n    var _field$alias5;\n\n    var applicationName = (_field$alias5 = field.alias) !== null && _field$alias5 !== void 0 ? _field$alias5 : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var linkedIDs = RelayModernRecord.getLinkedRecordIDs(record, storageKey);\n\n    if (linkedIDs == null) {\n      data[applicationName] = linkedIDs;\n\n      if (linkedIDs === undefined) {\n        this._isMissingData = true;\n      }\n\n      return linkedIDs;\n    }\n\n    var prevData = data[applicationName];\n    !(prevData == null || Array.isArray(prevData)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an array, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevData) : invariant(false) : void 0;\n    var linkedArray = prevData || [];\n    linkedIDs.forEach(function (linkedID, nextIndex) {\n      if (linkedID == null) {\n        if (linkedID === undefined) {\n          _this2._isMissingData = true;\n        } // $FlowFixMe[cannot-write]\n\n\n        linkedArray[nextIndex] = linkedID;\n        return;\n      }\n\n      var prevItem = linkedArray[nextIndex];\n      !(prevItem == null || typeof prevItem === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an object, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevItem) : invariant(false) : void 0; // $FlowFixMe[cannot-write]\n      // $FlowFixMe[incompatible-variance]\n\n      linkedArray[nextIndex] = _this2._traverse(field, linkedID, prevItem);\n    });\n    data[applicationName] = linkedArray;\n    return linkedArray;\n  }\n  /**\n   * Reads a ReaderModuleImport, which was generated from using the @module\n   * directive.\n   */\n  ;\n\n  _proto._readModuleImport = function _readModuleImport(moduleImport, record, data) {\n    // Determine the component module from the store: if the field is missing\n    // it means we don't know what component to render the match with.\n    var componentKey = getModuleComponentKey(moduleImport.documentName);\n    var component = RelayModernRecord.getValue(record, componentKey);\n\n    if (component == null) {\n      if (component === undefined) {\n        this._isMissingData = true;\n      }\n\n      return;\n    } // Otherwise, read the fragment and module associated to the concrete\n    // type, and put that data with the result:\n    // - For the matched fragment, create the relevant fragment pointer and add\n    //   the expected fragmentPropName\n    // - For the matched module, create a reference to the module\n\n\n    this._createFragmentPointer({\n      kind: 'FragmentSpread',\n      name: moduleImport.fragmentName,\n      args: moduleImport.args\n    }, record, data);\n\n    data[FRAGMENT_PROP_NAME_KEY] = moduleImport.fragmentPropName;\n    data[MODULE_COMPONENT_KEY] = component;\n  };\n\n  _proto._createFragmentPointer = function _createFragmentPointer(fragmentSpread, record, data) {\n    var fragmentPointers = data[FRAGMENTS_KEY];\n\n    if (fragmentPointers == null) {\n      fragmentPointers = data[FRAGMENTS_KEY] = {};\n    }\n\n    !(typeof fragmentPointers === 'object' && fragmentPointers != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader: Expected fragment spread data to be an object, got `%s`.', fragmentPointers) : invariant(false) : void 0;\n\n    if (data[ID_KEY] == null) {\n      data[ID_KEY] = RelayModernRecord.getDataID(record);\n    } // $FlowFixMe[cannot-write] - writing into read-only field\n\n\n    fragmentPointers[fragmentSpread.name] = fragmentSpread.args ? getArgumentValues(fragmentSpread.args, this._variables) : {};\n    data[FRAGMENT_OWNER_KEY] = this._owner;\n    data[IS_WITHIN_UNMATCHED_TYPE_REFINEMENT] = this._isWithinUnmatchedTypeRefinement;\n  };\n\n  _proto._createInlineDataOrResolverFragmentPointer = function _createInlineDataOrResolverFragmentPointer(fragmentSpreadOrFragment, record, data) {\n    var fragmentPointers = data[FRAGMENTS_KEY];\n\n    if (fragmentPointers == null) {\n      fragmentPointers = data[FRAGMENTS_KEY] = {};\n    }\n\n    !(typeof fragmentPointers === 'object' && fragmentPointers != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader: Expected fragment spread data to be an object, got `%s`.', fragmentPointers) : invariant(false) : void 0;\n\n    if (data[ID_KEY] == null) {\n      data[ID_KEY] = RelayModernRecord.getDataID(record);\n    }\n\n    var inlineData = {};\n\n    this._traverseSelections(fragmentSpreadOrFragment.selections, record, inlineData); // $FlowFixMe[cannot-write] - writing into read-only field\n\n\n    fragmentPointers[fragmentSpreadOrFragment.name] = inlineData;\n  };\n\n  return RelayReader;\n}();\n\nmodule.exports = {\n  read: read\n};","map":{"version":3,"sources":["/home/akshay/Atishay/appointy-screening/node_modules/relay-runtime/lib/store/RelayReader.js"],"names":["_interopRequireDefault","require","_defineProperty2","ClientID","RelayFeatureFlags","RelayModernRecord","invariant","_require","ACTOR_CHANGE","CLIENT_EXTENSION","CONDITION","DEFER","FLIGHT_FIELD","FRAGMENT_SPREAD","INLINE_DATA_FRAGMENT_SPREAD","INLINE_FRAGMENT","LINKED_FIELD","MODULE_IMPORT","REQUIRED_FIELD","RELAY_RESOLVER","SCALAR_FIELD","STREAM","_require2","getReactFlightClientResponse","_require3","FRAGMENTS_KEY","FRAGMENT_OWNER_KEY","FRAGMENT_PROP_NAME_KEY","ID_KEY","IS_WITHIN_UNMATCHED_TYPE_REFINEMENT","MODULE_COMPONENT_KEY","ROOT_ID","getArgumentValues","getStorageKey","getModuleComponentKey","_require4","NoopResolverCache","_require5","withResolverContext","_require6","generateTypeID","read","recordSource","selector","resolverCache","reader","RelayReader","_isMissingData","_isWithinUnmatchedTypeRefinement","_missingRequiredFields","_owner","owner","_recordSource","_seenRecords","Set","_selector","_variables","variables","_resolverCache","_proto","prototype","_this$_selector","node","dataID","isWithinUnmatchedTypeRefinement","abstractKey","record","get","isDataExpectedToBePresent","recordType","getType","type","_recordType","typeID","typeRecord","implementsInterface","getValue","data","_traverse","isMissingData","seenRecords","missingRequiredFields","prevData","add","undefined","hadRequiredData","_traverseSelections","selections","_getVariableValue","name","hasOwnProperty","process","env","NODE_ENV","_maybeReportUnexpectedNull","fieldPath","action","_this$_missingRequire","field","path","fields","push","i","length","selection","kind","ENABLE_REQUIRED_DIRECTIVES","fieldValue","_readRequiredField","_readScalar","plural","_readPluralLink","_readLink","conditionValue","Boolean","condition","passingValue","hasExpectedData","typeName","_hasExpectedData","parentIsMissingData","parentIsWithinUnmatchedTypeRefinement","_typeName","ENABLE_RELAY_RESOLVERS","Error","_readResolverField","_createFragmentPointer","_readModuleImport","_createInlineDataOrResolverFragmentPointer","_hasExpectedData2","_hasExpectedData3","ENABLE_REACT_FLIGHT_COMPONENT_FIELD","_readFlightField","_readActorChange","_this","resolverModule","fragment","storageKey","resolverID","generateClientID","getDataID","fragmentValue","fragmentReaderSelector","fragmentSeenRecordIDs","getDataForResolverFragment","singularReaderSelector","existingSeenRecords","_resolverFragmentData","resolverFragmentData","concat","resolverContext","_this$_resolverCache$","readFromCacheOrEvaluate","key","__id","__fragmentOwner","__fragments","resolverResult","seenRecordIDs","readerSelector","result","seenRecord","_field$alias","applicationName","alias","reactFlightClientResponseRecordID","getLinkedRecordID","reactFlightClientResponseRecord","clientResponse","_field$alias2","value","_field$alias3","linkedID","_field$alias4","externalRef","getActorLinkedRecordID","actorIdentifier","fragmentRef","fragmentSpread","__fragmentRef","__viewer","_this2","_field$alias5","linkedIDs","getLinkedRecordIDs","Array","isArray","linkedArray","forEach","nextIndex","prevItem","moduleImport","componentKey","documentName","component","fragmentName","args","fragmentPropName","fragmentPointers","fragmentSpreadOrFragment","inlineData","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar ClientID = require('./ClientID');\n\nvar RelayFeatureFlags = require('../util/RelayFeatureFlags');\n\nvar RelayModernRecord = require('./RelayModernRecord');\n\nvar invariant = require('invariant');\n\nvar _require = require('../util/RelayConcreteNode'),\n    ACTOR_CHANGE = _require.ACTOR_CHANGE,\n    CLIENT_EXTENSION = _require.CLIENT_EXTENSION,\n    CONDITION = _require.CONDITION,\n    DEFER = _require.DEFER,\n    FLIGHT_FIELD = _require.FLIGHT_FIELD,\n    FRAGMENT_SPREAD = _require.FRAGMENT_SPREAD,\n    INLINE_DATA_FRAGMENT_SPREAD = _require.INLINE_DATA_FRAGMENT_SPREAD,\n    INLINE_FRAGMENT = _require.INLINE_FRAGMENT,\n    LINKED_FIELD = _require.LINKED_FIELD,\n    MODULE_IMPORT = _require.MODULE_IMPORT,\n    REQUIRED_FIELD = _require.REQUIRED_FIELD,\n    RELAY_RESOLVER = _require.RELAY_RESOLVER,\n    SCALAR_FIELD = _require.SCALAR_FIELD,\n    STREAM = _require.STREAM;\n\nvar _require2 = require('./RelayStoreReactFlightUtils'),\n    getReactFlightClientResponse = _require2.getReactFlightClientResponse;\n\nvar _require3 = require('./RelayStoreUtils'),\n    FRAGMENTS_KEY = _require3.FRAGMENTS_KEY,\n    FRAGMENT_OWNER_KEY = _require3.FRAGMENT_OWNER_KEY,\n    FRAGMENT_PROP_NAME_KEY = _require3.FRAGMENT_PROP_NAME_KEY,\n    ID_KEY = _require3.ID_KEY,\n    IS_WITHIN_UNMATCHED_TYPE_REFINEMENT = _require3.IS_WITHIN_UNMATCHED_TYPE_REFINEMENT,\n    MODULE_COMPONENT_KEY = _require3.MODULE_COMPONENT_KEY,\n    ROOT_ID = _require3.ROOT_ID,\n    getArgumentValues = _require3.getArgumentValues,\n    getStorageKey = _require3.getStorageKey,\n    getModuleComponentKey = _require3.getModuleComponentKey;\n\nvar _require4 = require('./ResolverCache'),\n    NoopResolverCache = _require4.NoopResolverCache;\n\nvar _require5 = require('./ResolverFragments'),\n    withResolverContext = _require5.withResolverContext;\n\nvar _require6 = require('./TypeID'),\n    generateTypeID = _require6.generateTypeID;\n\nfunction read(recordSource, selector, resolverCache) {\n  var reader = new RelayReader(recordSource, selector, resolverCache !== null && resolverCache !== void 0 ? resolverCache : new NoopResolverCache());\n  return reader.read();\n}\n/**\n * @private\n */\n\n\nvar RelayReader = /*#__PURE__*/function () {\n  function RelayReader(recordSource, selector, resolverCache) {\n    this._isMissingData = false;\n    this._isWithinUnmatchedTypeRefinement = false;\n    this._missingRequiredFields = null;\n    this._owner = selector.owner;\n    this._recordSource = recordSource;\n    this._seenRecords = new Set();\n    this._selector = selector;\n    this._variables = selector.variables;\n    this._resolverCache = resolverCache;\n  }\n\n  var _proto = RelayReader.prototype;\n\n  _proto.read = function read() {\n    var _this$_selector = this._selector,\n        node = _this$_selector.node,\n        dataID = _this$_selector.dataID,\n        isWithinUnmatchedTypeRefinement = _this$_selector.isWithinUnmatchedTypeRefinement;\n    var abstractKey = node.abstractKey;\n\n    var record = this._recordSource.get(dataID); // Relay historically allowed child fragments to be read even if the root object\n    // did not match the type of the fragment: either the root object has a different\n    // concrete type than the fragment (for concrete fragments) or the root object does\n    // not conform to the interface/union for abstract fragments.\n    // For suspense purposes, however, we want to accurately compute whether any data\n    // is missing: but if the fragment type doesn't match (or a parent type didn't\n    // match), then no data is expected to be present.\n    // By default data is expected to be present unless this selector was read out\n    // from within a non-matching type refinement in a parent fragment:\n\n\n    var isDataExpectedToBePresent = !isWithinUnmatchedTypeRefinement; // If this is a concrete fragment and the concrete type of the record does not\n    // match, then no data is expected to be present.\n\n    if (isDataExpectedToBePresent && abstractKey == null && record != null) {\n      var recordType = RelayModernRecord.getType(record);\n\n      if (recordType !== node.type && // The root record type is a special `__Root` type and may not match the\n      // type on the ast, so ignore type mismatches at the root.\n      // We currently detect whether we're at the root by checking against ROOT_ID,\n      // but this does not work for mutations/subscriptions which generate unique\n      // root ids. This is acceptable in practice as we don't read data for mutations/\n      // subscriptions in a situation where we would use isMissingData to decide whether\n      // to suspend or not.\n      // TODO T96653810: Correctly detect reading from root of mutation/subscription\n      dataID !== ROOT_ID) {\n        isDataExpectedToBePresent = false;\n      }\n    } // If this is an abstract fragment (and the precise refinement GK is enabled)\n    // then data is only expected to be present if the record type is known to\n    // implement the interface. If we aren't sure whether the record implements\n    // the interface, that itself constitutes \"expected\" data being missing.\n\n\n    if (isDataExpectedToBePresent && abstractKey != null && record != null) {\n      var _recordType = RelayModernRecord.getType(record);\n\n      var typeID = generateTypeID(_recordType);\n\n      var typeRecord = this._recordSource.get(typeID);\n\n      var implementsInterface = typeRecord != null ? RelayModernRecord.getValue(typeRecord, abstractKey) : null;\n\n      if (implementsInterface === false) {\n        // Type known to not implement the interface\n        isDataExpectedToBePresent = false;\n      } else if (implementsInterface == null) {\n        // Don't know if the type implements the interface or not\n        this._isMissingData = true;\n      }\n    }\n\n    this._isWithinUnmatchedTypeRefinement = !isDataExpectedToBePresent;\n\n    var data = this._traverse(node, dataID, null);\n\n    return {\n      data: data,\n      isMissingData: this._isMissingData && isDataExpectedToBePresent,\n      seenRecords: this._seenRecords,\n      selector: this._selector,\n      missingRequiredFields: this._missingRequiredFields\n    };\n  };\n\n  _proto._traverse = function _traverse(node, dataID, prevData) {\n    var record = this._recordSource.get(dataID);\n\n    this._seenRecords.add(dataID);\n\n    if (record == null) {\n      if (record === undefined) {\n        this._isMissingData = true;\n      }\n\n      return record;\n    }\n\n    var data = prevData || {};\n\n    var hadRequiredData = this._traverseSelections(node.selections, record, data);\n\n    return hadRequiredData ? data : null;\n  };\n\n  _proto._getVariableValue = function _getVariableValue(name) {\n    !this._variables.hasOwnProperty(name) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Undefined variable `%s`.', name) : invariant(false) : void 0; // $FlowFixMe[cannot-write]\n\n    return this._variables[name];\n  };\n\n  _proto._maybeReportUnexpectedNull = function _maybeReportUnexpectedNull(fieldPath, action, record) {\n    var _this$_missingRequire;\n\n    if (((_this$_missingRequire = this._missingRequiredFields) === null || _this$_missingRequire === void 0 ? void 0 : _this$_missingRequire.action) === 'THROW') {\n      // Chained @required directives may cause a parent `@required(action:\n      // THROW)` field to become null, so the first missing field we\n      // encounter is likely to be the root cause of the error.\n      return;\n    }\n\n    var owner = this._selector.node.name;\n\n    switch (action) {\n      case 'THROW':\n        this._missingRequiredFields = {\n          action: action,\n          field: {\n            path: fieldPath,\n            owner: owner\n          }\n        };\n        return;\n\n      case 'LOG':\n        if (this._missingRequiredFields == null) {\n          this._missingRequiredFields = {\n            action: action,\n            fields: []\n          };\n        }\n\n        this._missingRequiredFields.fields.push({\n          path: fieldPath,\n          owner: owner\n        });\n\n        return;\n\n      default:\n        action;\n    }\n  };\n\n  _proto._traverseSelections = function _traverseSelections(selections, record, data)\n  /* had all expected data */\n  {\n    for (var i = 0; i < selections.length; i++) {\n      var selection = selections[i];\n\n      switch (selection.kind) {\n        case REQUIRED_FIELD:\n          !RelayFeatureFlags.ENABLE_REQUIRED_DIRECTIVES ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Encountered a `@required` directive at path \"%s\" in `%s` without the `ENABLE_REQUIRED_DIRECTIVES` feature flag enabled.', selection.path, this._selector.node.name) : invariant(false) : void 0;\n\n          var fieldValue = this._readRequiredField(selection, record, data);\n\n          if (fieldValue == null) {\n            var action = selection.action;\n\n            if (action !== 'NONE') {\n              this._maybeReportUnexpectedNull(selection.path, action, record);\n            } // We are going to throw, or our parent is going to get nulled out.\n            // Either way, sibling values are going to be ignored, so we can\n            // bail early here as an optimization.\n\n\n            return false;\n          }\n\n          break;\n\n        case SCALAR_FIELD:\n          this._readScalar(selection, record, data);\n\n          break;\n\n        case LINKED_FIELD:\n          if (selection.plural) {\n            this._readPluralLink(selection, record, data);\n          } else {\n            this._readLink(selection, record, data);\n          }\n\n          break;\n\n        case CONDITION:\n          var conditionValue = Boolean(this._getVariableValue(selection.condition));\n\n          if (conditionValue === selection.passingValue) {\n            var hasExpectedData = this._traverseSelections(selection.selections, record, data);\n\n            if (!hasExpectedData) {\n              return false;\n            }\n          }\n\n          break;\n\n        case INLINE_FRAGMENT:\n          {\n            var abstractKey = selection.abstractKey;\n\n            if (abstractKey == null) {\n              // concrete type refinement: only read data if the type exactly matches\n              var typeName = RelayModernRecord.getType(record);\n\n              if (typeName != null && typeName === selection.type) {\n                var _hasExpectedData = this._traverseSelections(selection.selections, record, data);\n\n                if (!_hasExpectedData) {\n                  return false;\n                }\n              }\n            } else {\n              // Similar to the logic in read(): data is only expected to be present\n              // if the record is known to conform to the interface. If we don't know\n              // whether the type conforms or not, that constitutes missing data.\n              // store flags to reset after reading\n              var parentIsMissingData = this._isMissingData;\n              var parentIsWithinUnmatchedTypeRefinement = this._isWithinUnmatchedTypeRefinement;\n\n              var _typeName = RelayModernRecord.getType(record);\n\n              var typeID = generateTypeID(_typeName);\n\n              var typeRecord = this._recordSource.get(typeID);\n\n              var implementsInterface = typeRecord != null ? RelayModernRecord.getValue(typeRecord, abstractKey) : null;\n              this._isWithinUnmatchedTypeRefinement = parentIsWithinUnmatchedTypeRefinement || implementsInterface === false;\n\n              this._traverseSelections(selection.selections, record, data);\n\n              this._isWithinUnmatchedTypeRefinement = parentIsWithinUnmatchedTypeRefinement;\n\n              if (implementsInterface === false) {\n                // Type known to not implement the interface, no data expected\n                this._isMissingData = parentIsMissingData;\n              } else if (implementsInterface == null) {\n                // Don't know if the type implements the interface or not\n                this._isMissingData = true;\n              }\n            }\n\n            break;\n          }\n\n        case RELAY_RESOLVER:\n          {\n            if (!RelayFeatureFlags.ENABLE_RELAY_RESOLVERS) {\n              throw new Error('Relay Resolver fields are not yet supported.');\n            }\n\n            this._readResolverField(selection, record, data);\n\n            break;\n          }\n\n        case FRAGMENT_SPREAD:\n          this._createFragmentPointer(selection, record, data);\n\n          break;\n\n        case MODULE_IMPORT:\n          this._readModuleImport(selection, record, data);\n\n          break;\n\n        case INLINE_DATA_FRAGMENT_SPREAD:\n          this._createInlineDataOrResolverFragmentPointer(selection, record, data);\n\n          break;\n\n        case DEFER:\n        case CLIENT_EXTENSION:\n          {\n            var isMissingData = this._isMissingData;\n\n            var _hasExpectedData2 = this._traverseSelections(selection.selections, record, data);\n\n            this._isMissingData = isMissingData;\n\n            if (!_hasExpectedData2) {\n              return false;\n            }\n\n            break;\n          }\n\n        case STREAM:\n          {\n            var _hasExpectedData3 = this._traverseSelections(selection.selections, record, data);\n\n            if (!_hasExpectedData3) {\n              return false;\n            }\n\n            break;\n          }\n\n        case FLIGHT_FIELD:\n          if (RelayFeatureFlags.ENABLE_REACT_FLIGHT_COMPONENT_FIELD) {\n            this._readFlightField(selection, record, data);\n          } else {\n            throw new Error('Flight fields are not yet supported.');\n          }\n\n          break;\n\n        case ACTOR_CHANGE:\n          this._readActorChange(selection, record, data);\n\n          break;\n\n        default:\n          selection;\n          !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Unexpected ast kind `%s`.', selection.kind) : invariant(false) : void 0;\n      }\n    }\n\n    return true;\n  };\n\n  _proto._readRequiredField = function _readRequiredField(selection, record, data) {\n    switch (selection.field.kind) {\n      case SCALAR_FIELD:\n        return this._readScalar(selection.field, record, data);\n\n      case LINKED_FIELD:\n        if (selection.field.plural) {\n          return this._readPluralLink(selection.field, record, data);\n        } else {\n          return this._readLink(selection.field, record, data);\n        }\n\n      case RELAY_RESOLVER:\n        if (!RelayFeatureFlags.ENABLE_RELAY_RESOLVERS) {\n          throw new Error('Relay Resolver fields are not yet supported.');\n        }\n\n        this._readResolverField(selection.field, record, data);\n\n        break;\n\n      default:\n        selection.field.kind;\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Unexpected ast kind `%s`.', selection.kind) : invariant(false) : void 0;\n    }\n  };\n\n  _proto._readResolverField = function _readResolverField(field, record, data) {\n    var _this = this;\n\n    var resolverModule = field.resolverModule,\n        fragment = field.fragment;\n    var storageKey = getStorageKey(field, this._variables);\n    var resolverID = ClientID.generateClientID(RelayModernRecord.getDataID(record), storageKey); // Found when reading the resolver fragment, which can happen either when\n    // evaluating the resolver and it calls readFragment, or when checking if the\n    // inputs have changed since a previous evaluation:\n\n    var fragmentValue;\n    var fragmentReaderSelector;\n    var fragmentSeenRecordIDs = new Set();\n\n    var getDataForResolverFragment = function getDataForResolverFragment(singularReaderSelector) {\n      if (fragmentValue != null) {\n        // It was already read when checking for input staleness; no need to read it again.\n        // Note that the variables like fragmentSeenRecordIDs in the outer closure will have\n        // already been set and will still be used in this case.\n        return fragmentValue;\n      }\n\n      fragmentReaderSelector = singularReaderSelector;\n      var existingSeenRecords = _this._seenRecords;\n\n      try {\n        var _resolverFragmentData;\n\n        _this._seenRecords = fragmentSeenRecordIDs;\n        var resolverFragmentData = {};\n\n        _this._createInlineDataOrResolverFragmentPointer(singularReaderSelector.node, record, resolverFragmentData);\n\n        fragmentValue = (_resolverFragmentData = resolverFragmentData[FRAGMENTS_KEY]) === null || _resolverFragmentData === void 0 ? void 0 : _resolverFragmentData[fragment.name];\n        !(typeof fragmentValue === 'object' && fragmentValue !== null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Expected reader data to contain a __fragments property with a property for the fragment named \".concat(fragment.name, \", but it is missing.\")) : invariant(false) : void 0;\n        return fragmentValue;\n      } finally {\n        _this._seenRecords = existingSeenRecords;\n      }\n    };\n\n    var resolverContext = {\n      getDataForResolverFragment: getDataForResolverFragment\n    };\n\n    var _this$_resolverCache$ = this._resolverCache.readFromCacheOrEvaluate(record, field, this._variables, function () {\n      var key = {\n        __id: RelayModernRecord.getDataID(record),\n        __fragmentOwner: _this._owner,\n        __fragments: (0, _defineProperty2[\"default\"])({}, fragment.name, {})\n      };\n      return withResolverContext(resolverContext, function () {\n        // $FlowFixMe[prop-missing] - resolver module's type signature is a lie\n        var resolverResult = resolverModule(key);\n        return {\n          resolverResult: resolverResult,\n          fragmentValue: fragmentValue,\n          resolverID: resolverID,\n          seenRecordIDs: fragmentSeenRecordIDs,\n          readerSelector: fragmentReaderSelector\n        };\n      });\n    }, getDataForResolverFragment),\n        result = _this$_resolverCache$[0],\n        seenRecord = _this$_resolverCache$[1];\n\n    if (seenRecord != null) {\n      this._seenRecords.add(seenRecord);\n    }\n\n    data[storageKey] = result;\n    return result;\n  };\n\n  _proto._readFlightField = function _readFlightField(field, record, data) {\n    var _field$alias;\n\n    var applicationName = (_field$alias = field.alias) !== null && _field$alias !== void 0 ? _field$alias : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var reactFlightClientResponseRecordID = RelayModernRecord.getLinkedRecordID(record, storageKey);\n\n    if (reactFlightClientResponseRecordID == null) {\n      data[applicationName] = reactFlightClientResponseRecordID;\n\n      if (reactFlightClientResponseRecordID === undefined) {\n        this._isMissingData = true;\n      }\n\n      return reactFlightClientResponseRecordID;\n    }\n\n    var reactFlightClientResponseRecord = this._recordSource.get(reactFlightClientResponseRecordID);\n\n    this._seenRecords.add(reactFlightClientResponseRecordID);\n\n    if (reactFlightClientResponseRecord == null) {\n      data[applicationName] = reactFlightClientResponseRecord;\n\n      if (reactFlightClientResponseRecord === undefined) {\n        this._isMissingData = true;\n      }\n\n      return reactFlightClientResponseRecord;\n    }\n\n    var clientResponse = getReactFlightClientResponse(reactFlightClientResponseRecord);\n    data[applicationName] = clientResponse;\n    return clientResponse;\n  };\n\n  _proto._readScalar = function _readScalar(field, record, data) {\n    var _field$alias2;\n\n    var applicationName = (_field$alias2 = field.alias) !== null && _field$alias2 !== void 0 ? _field$alias2 : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var value = RelayModernRecord.getValue(record, storageKey);\n\n    if (value === undefined) {\n      this._isMissingData = true;\n    }\n\n    data[applicationName] = value;\n    return value;\n  };\n\n  _proto._readLink = function _readLink(field, record, data) {\n    var _field$alias3;\n\n    var applicationName = (_field$alias3 = field.alias) !== null && _field$alias3 !== void 0 ? _field$alias3 : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var linkedID = RelayModernRecord.getLinkedRecordID(record, storageKey);\n\n    if (linkedID == null) {\n      data[applicationName] = linkedID;\n\n      if (linkedID === undefined) {\n        this._isMissingData = true;\n      }\n\n      return linkedID;\n    }\n\n    var prevData = data[applicationName];\n    !(prevData == null || typeof prevData === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an object, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevData) : invariant(false) : void 0; // $FlowFixMe[incompatible-variance]\n\n    var value = this._traverse(field, linkedID, prevData);\n\n    data[applicationName] = value;\n    return value;\n  };\n\n  _proto._readActorChange = function _readActorChange(field, record, data) {\n    var _field$alias4;\n\n    var applicationName = (_field$alias4 = field.alias) !== null && _field$alias4 !== void 0 ? _field$alias4 : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var externalRef = RelayModernRecord.getActorLinkedRecordID(record, storageKey);\n\n    if (externalRef == null) {\n      data[applicationName] = externalRef;\n\n      if (externalRef === undefined) {\n        this._isMissingData = true;\n      }\n\n      return data[applicationName];\n    }\n\n    var actorIdentifier = externalRef[0],\n        dataID = externalRef[1];\n    var fragmentRef = {};\n\n    this._createFragmentPointer(field.fragmentSpread, {\n      __id: dataID\n    }, fragmentRef);\n\n    data[applicationName] = {\n      __fragmentRef: fragmentRef,\n      __viewer: actorIdentifier\n    };\n    return data[applicationName];\n  };\n\n  _proto._readPluralLink = function _readPluralLink(field, record, data) {\n    var _this2 = this;\n\n    var _field$alias5;\n\n    var applicationName = (_field$alias5 = field.alias) !== null && _field$alias5 !== void 0 ? _field$alias5 : field.name;\n    var storageKey = getStorageKey(field, this._variables);\n    var linkedIDs = RelayModernRecord.getLinkedRecordIDs(record, storageKey);\n\n    if (linkedIDs == null) {\n      data[applicationName] = linkedIDs;\n\n      if (linkedIDs === undefined) {\n        this._isMissingData = true;\n      }\n\n      return linkedIDs;\n    }\n\n    var prevData = data[applicationName];\n    !(prevData == null || Array.isArray(prevData)) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an array, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevData) : invariant(false) : void 0;\n    var linkedArray = prevData || [];\n    linkedIDs.forEach(function (linkedID, nextIndex) {\n      if (linkedID == null) {\n        if (linkedID === undefined) {\n          _this2._isMissingData = true;\n        } // $FlowFixMe[cannot-write]\n\n\n        linkedArray[nextIndex] = linkedID;\n        return;\n      }\n\n      var prevItem = linkedArray[nextIndex];\n      !(prevItem == null || typeof prevItem === 'object') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader(): Expected data for field `%s` on record `%s` ' + 'to be an object, got `%s`.', applicationName, RelayModernRecord.getDataID(record), prevItem) : invariant(false) : void 0; // $FlowFixMe[cannot-write]\n      // $FlowFixMe[incompatible-variance]\n\n      linkedArray[nextIndex] = _this2._traverse(field, linkedID, prevItem);\n    });\n    data[applicationName] = linkedArray;\n    return linkedArray;\n  }\n  /**\n   * Reads a ReaderModuleImport, which was generated from using the @module\n   * directive.\n   */\n  ;\n\n  _proto._readModuleImport = function _readModuleImport(moduleImport, record, data) {\n    // Determine the component module from the store: if the field is missing\n    // it means we don't know what component to render the match with.\n    var componentKey = getModuleComponentKey(moduleImport.documentName);\n    var component = RelayModernRecord.getValue(record, componentKey);\n\n    if (component == null) {\n      if (component === undefined) {\n        this._isMissingData = true;\n      }\n\n      return;\n    } // Otherwise, read the fragment and module associated to the concrete\n    // type, and put that data with the result:\n    // - For the matched fragment, create the relevant fragment pointer and add\n    //   the expected fragmentPropName\n    // - For the matched module, create a reference to the module\n\n\n    this._createFragmentPointer({\n      kind: 'FragmentSpread',\n      name: moduleImport.fragmentName,\n      args: moduleImport.args\n    }, record, data);\n\n    data[FRAGMENT_PROP_NAME_KEY] = moduleImport.fragmentPropName;\n    data[MODULE_COMPONENT_KEY] = component;\n  };\n\n  _proto._createFragmentPointer = function _createFragmentPointer(fragmentSpread, record, data) {\n    var fragmentPointers = data[FRAGMENTS_KEY];\n\n    if (fragmentPointers == null) {\n      fragmentPointers = data[FRAGMENTS_KEY] = {};\n    }\n\n    !(typeof fragmentPointers === 'object' && fragmentPointers != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader: Expected fragment spread data to be an object, got `%s`.', fragmentPointers) : invariant(false) : void 0;\n\n    if (data[ID_KEY] == null) {\n      data[ID_KEY] = RelayModernRecord.getDataID(record);\n    } // $FlowFixMe[cannot-write] - writing into read-only field\n\n\n    fragmentPointers[fragmentSpread.name] = fragmentSpread.args ? getArgumentValues(fragmentSpread.args, this._variables) : {};\n    data[FRAGMENT_OWNER_KEY] = this._owner;\n    data[IS_WITHIN_UNMATCHED_TYPE_REFINEMENT] = this._isWithinUnmatchedTypeRefinement;\n  };\n\n  _proto._createInlineDataOrResolverFragmentPointer = function _createInlineDataOrResolverFragmentPointer(fragmentSpreadOrFragment, record, data) {\n    var fragmentPointers = data[FRAGMENTS_KEY];\n\n    if (fragmentPointers == null) {\n      fragmentPointers = data[FRAGMENTS_KEY] = {};\n    }\n\n    !(typeof fragmentPointers === 'object' && fragmentPointers != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'RelayReader: Expected fragment spread data to be an object, got `%s`.', fragmentPointers) : invariant(false) : void 0;\n\n    if (data[ID_KEY] == null) {\n      data[ID_KEY] = RelayModernRecord.getDataID(record);\n    }\n\n    var inlineData = {};\n\n    this._traverseSelections(fragmentSpreadOrFragment.selections, record, inlineData); // $FlowFixMe[cannot-write] - writing into read-only field\n\n\n    fragmentPointers[fragmentSpreadOrFragment.name] = inlineData;\n  };\n\n  return RelayReader;\n}();\n\nmodule.exports = {\n  read: read\n};"]},"metadata":{},"sourceType":"script"}